ZVSE2
** Author orig.  : Algor
** Update        : Archer30
** Name          : Military duty
** Name rus.     : Воинская обязанность
** Options       : 994

** Каждое воскресенье невыкупленные существа из захваченных внешних жилищ прибывают для найма в первый город игрока, с подходящим отстроенным зданием.
** Если города с подходящим отстроенным зданием у игрока нет, существа остаются во внешних жилищах.
** Порядок выбора города из нескольких подходящих, определяется порядком в списке городов игрока,
** который может быть изменен при использовании WoG-опци 244 "Сортировка списка героев и городов"
** Существа "8го уровня" воинской обязанности не подлежат и попадают в города героя стандартным для них путем.


!?FU(OnEveryDay)&i^timerWeekday^=7;
!!UN:P994/?y1;
!!FU&y1<>1:E;                          [выход, если опция 994 не включена]

!!OW:C?y2;                             [y2 - текущий игрок]
!!UN:U(OBJ_CREATURE_GENERATOR_1)/-1/?y1;
!!VRv10:S-1;                           [y1 - количество жилищ на карте (тип 17), инициализация v10 для быстрого поиска]
!!DO(ES_994_CheckForDwellings)/1/y1/1&y1>0:Py2/(OBJ_CREATURE_GENERATOR_1);           [для каждого жилища призываем обитателей в подходящие города игрока]
!!UN:U(OBJ_CREATURE_GENERATOR_4)/-1/?y1;
!!VRv10:S-1;                           [y1 - количество жилищ на карте (тип 20), инициализация v10 для быстрого поиска]
!!DO(ES_994_CheckForDwellings)/1/y1/1&y1>0:Py2/(OBJ_CREATURE_GENERATOR_4);           [для каждого жилища призываем обитателей в подходящие города игрока]

!?FU(ES_994_CheckForDwellings);
!!UN:Ux2/-1/-1/10;                     [v10..v12 - dwelling coordinates]
!!DW10:O?y1/1;
!!FU&y1<>x1:E;                         [выход, если жилище не принадлежит текущему игроку]

!!DO(ES_994_CheckForDwellSlots)/0/3/1:Px1;                    [перебор слотов жилища]

!?FU(ES_994_CheckForDwellSlots);                              [проверка слота жилища]
!!DW10:Mx16/?y1/?y2;                   [y1/y2 - тип и кол-во доступных существ в 1м слоте жилища]

!!if&y1>(NO_MON)/y2>0;                 [если в слоте жилища есть существа]
  !!VRy5:S-2; !!VRy6:S-2;              [инициализация переменных]
  !!MA:Oy1/?y3 Ly1/?y4;                [y3/y4 - тип города, которому принадлежит существо / уровень существа]

  !!if&y3>(NO_TOWN);
    !!FU(ES_994_GetDegradedMonOrSelf):Py1/?y30;
    !!UN:Ty3/y4/0/?y5;             [y5 - тип существа для найма в подходящем городе (баз.)]
  !!en;

  !!if&y5=y30;                         [если существо возможно нанять в городе (не нейтрал)]
    !!OW:Wx1/?y7; !!VRy7:-1;           [y7 - количество городов у игрока-1]
    !!VRv13:S-1;                       [инициализация v13 - номер подходящего города]
    !!VRy8:Sy4 +30; !!VRy8&y6=y1:+7;   [y8 - номер необходимого здания для перемещения существ]

    !!DO(ES_994_CheckForOwnedTowns)/0/y7/1&y7>=0:Px1/y3/y8;   [v13 - номер подходящего города для перемещения существ]

    !!if&v13>=0;                       [если город найден]
      !!VRy8&y8<37:+7; !!CA0/v13:B3/y8;[f1=1, если отстроено улучшенное жилище]

      !!if&1;                          [если отстроено улучшенное жилище]
        !!CA0/v13:M1/y4/d/dy2;         [увеличиваем кол-во доступных улучшенных существ]
      !!el;                            [иначе]
        !!CA0/v13:M1/y4/dy2/d;         [увеличиваем кол-во доступных неулучшенных существ]
      !!en;

      !!DW10:Mx16/d/0;                 [удаляем существ из слота внешнего жилища]
    !!en;
  !!en;
!!en;

!?FU(ES_994_CheckForOwnedTowns);                              [поиск подходящего города]
!!OW:Wx1/x16/?y1;                      [y1 - номер города на карте]
!!CA0/y1:T?y2 B3/x3; !!FU|-1/y2<>x2:E; [выход, если город не подходящего типа или в нем не отстроено подходящее жилище]

!!VRv13:Sy1; !!VRx16:S99;              [v13 - номер (на карте) подходящего города, прерывание поиска]

!?FU(ES_994_GetDegradedMonOrSelf);
!#VA(monId:x) (degradedMon:x);

!!VR(degradedMon):S(monId);
!!FU(NewIntArray):P?(degradedMons:y);

; Check for the degraded creature and push to the array if degrade is possible. Check for 5 times at most
!!re i/0/4;
  !!FU(GetDegradedMonCandidates):P(monId:x)/?(degradesList:y);
  !!SN:M(degradesList)/?(size:y);

  !!if&(size)<>0;
    !!SN:M(degradesList)/0/?(monId);
    !!FU(Array_Push):P(degradedMons)/(monId);
  !!el;
    !!br;
  !!en;
!!en;

; Loop through the array and get the creature with the lowest fight value as the most degraded form
!!SN:M(degradedMons)?(size);

!!if&(size)>0;
  !!VR(lowestFv:y):S(INT_MAX);

  !!re (index:y)/0/(size)/1/-1;
    !!SN:M(degradedMons)/(index)/?(mon:y);
    !!MA:F(mon)/?(fv:y);

    !!if&(fv)<=(lowestFv);
      !!VR(lowestFv):S(fv);
      !!VR(degradedMon):S(mon);
    !!en;
  !!en;
!!en;

** end
