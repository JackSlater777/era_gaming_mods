ZVSE2
; Author:   Archer30, daemon_n and various authors
; Engine:   ERM 2.0+
; Requires: ERA 3.3+, Era Erm Framework


********************************
**** Option Compatibilities ****
********************************
// Get the number of War Machines of Enhanced War Machines III at the end of battle
!?FU(OnAfterBattleAction);
!!UN:P73/?(wogOption:y);
!!FU&(wogOption)<>(TRUE):E;

!!BU:C?(battleIsEnded:y);

!!if&(battleIsEnded);

  ; Get the hero who won the battle, exit if no one won
  !!VR(wonHero:y):S(NO_HERO);

  !!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);
    !!HEi^battle_hero_%i^:O?(owner:y);

    !!if&(owner)>(NO_OWNER);
      !!VR(wonHero):Si^battle_hero_%i^;
      !!VR(lostSide:y):Si X1;
      !!VR(lostHero:y):Si^battle_hero_%(lostSide)^;

      !!br;
    !!en;
  !!en;

  !!FU&(wonHero)=(NO_HERO):E;

  ; Get the number of the remaining War Machines of the lost hero
  !!IF:W(lostHero);
  !!VRi^es_737_capturedWM1^:Sw81;
  !!VRi^es_737_capturedWM2^:Sw82;
  !!VRi^es_737_capturedWM3^:Sw83;
!!en;

// Disable Rebalanced Starting Armies (WoG) if Balanced Starting Army (ES) is enabled
!?FU(ES_764_Initialization);
!!UN:P764/?(wogOption:y);               [проверяем включена ли опция 764 в v1]

; Check if the current map is a random map, disable Balanced Starting Army (ES) if not
!!if&(wogOption);
  !!FU(ES_CheckRandomMap):P?(isRandMap:y);

  !!if&(isRandMap)<>(TRUE);
    !!UN:P764/(FALSE);                  [отключение опции для нерандомной карты]
  ; Disable Rebalanced Starting Armies (WoG) if the map is a random map
  !!el;
    !!UN:P199/(FALSE);                  [отключаем опцию 199 "Измененные стартовые армии героев"]
    !!VRi^wog_199_enabled^:S(FALSE);
  !!en;
!!en;

// Check if the current map is a random map
// This function must be put exactly this place in order to be executed by FU(ES_764_Initialization)
!?FU(ES_CheckRandomMap);
!#VA(result:x);

!!VR(result):S(FALSE);
!!UN:C6919480/4/?(value:y);
!!VR(address:y):S(value) +128980;
!!UN:C(address)/1/?(value2:y);              [(value2)=114 -> random map]

!!VR(result)&(value2)=114:S(TRUE);

!#FU(ES_764_Initialization):P;

// Temporally disable Extension Heroes if Tyrant is enabled, would be re-enabled again when the tyrant is set up
// This is to make sure the tyrant has the highest priority to get these Extension heroes
!?FU(ES_770_DisableExtensionHeroes);
!!UN:P100/?i^wog_100_enabled^;
!!UN:P770/?(wogOption:y);
!!UN&(wogOption):P100/0;

!#FU(ES_770_DisableExtensionHeroes):P;

// Determine the mode of Landing Navigation by checking the percentage of water on the surface
!?FU(ES_773_Initialization);
; Loop through all the tiles on the surface to get the percentage of water
!!VR(waterTiles:y):S0;
!!UN:X?(width:y)/?(level:y);

!!re (x:y)/0/(width)/1/-1;
  !!re (y:y)/0/(width)/1/-1;
    !!TR(x)/(y)/0:T?(terrain:y);
    !!VR(waterTiles)&(terrain)=8:+1;    [8 = water]
  !!en;
!!en;

!!VR(totalTiles:y):S(width) *(width);
!!VR(waterPercent:y):S(waterTiles) *100 :(totalTiles);

!!if&(waterPercent)<15;
  ; Set the global variable for land mode
  !!UN:P773/2;
  !!VRi^es_773_landMode^:S(TRUE);

  ; Ban water artifacts and spells
  !!UN:P172/1 P164/1 P157/1;
  !!UN:A(ART_NECKLACE_OF_OCEAN_GUIDANCE)/1 A(ART_BOOTS_OF_LEVITATION)/1 A(ART_SEA_CAPTAINS_HAT)/1 A(ART_ADMIRALS_HAT)/1; [запрет водных артефактов]
  !!UN:P152/1 P153/1 P221/1;            [включение опций Бана водных заклинаний]
  !!UN:J0/(SPELL_SUMMON_BOAT)/1 J0/(SPELL_SCUTTLE_BOAT)/1 J0/(SPELL_WATER_WALK)/1; [Бан водных заклинаний в Гильдиях Магов и Пирамидах]
!!en;

; We seperate a function here for compatibilities
!#UN:P773/?(landNavi:y);                [проверяем включена ли опция 773]
!#FU(ES_773_Initialization)&(landNavi):P;

// The following changes are critical to the initialization of secondary skill text
// Disable Resistance II if Enhanced Resistance is enabled
!?FU(ES_777_DisableResistanceII);
!!UN:P777/?(enhResistance:y);           [проверяем включена ли опция 777]
!!UN&(enhResistance):P210/(FALSE);      [если включена, отключаем опцию Сопротивление II]

!#FU(ES_777_DisableResistanceII):P;

// Set the random hero to retreated in order to skip Mortal heroes's hero rebirth
// Execute sooner than random hero's global var i^wog_72_randHeroActive^ reset
!?FU(OnAfterBattleUniversal);           // после боя
!!UN:P788/?(wogOption:y);
!!FU&(wogOption)<>(TRUE):E;             // выход, если опция не включена

!!FU|i^es_788_lastBattleAction^=(BATTLE_ACTION_RETREAT)/i^es_788_lastBattleAction^=(BATTLE_ACTION_SURRENDER):E;                       // выход, если герой сбежал/откупился

!!BA:H0/?(leftHero:y) H1/?(rightHero:y);                     // атакующий/защищающийся герои, выход, если не битва двух героев
!!HE(leftHero):O?(leftOwner:y);
!!FU(ES_788_Rebirth)&(leftHero)>(NO_HERO)/(leftOwner)=(NO_OWNER):P(leftHero);    // перерождение атакующего героя, если он погиб

!!if&(rightHero)>(NO_HERO)/i^wog_72_randHeroActive^<>(TRUE);
  !!HE(rightHero):O?(rightOwner:y);                          // владельцы атакующеего/защищающегося героя
  !!FU(ES_788_Rebirth)&(rightOwner)=(NO_OWNER):P(rightHero);  // перерождение защищающегося героя, если он погиб
!!en;

// Disable Sorcery II if Critical Sorcery is re-enabled
!?FU(ES_789_DisableSorceryII);
!!UN:P789/?(critSorcery:y);             [проверяем включена ли опция 789]
!!UN&(critSorcery):P213/0;              [если включена, отключаем опцию Волшебство II]

!#FU(ES_789_DisableSorceryII):P;

// Ask to write a spell to the spell book if condition has been meet
// Execute sooner than daemon_n's Spell Research
!?FU(OnTownMouseClick)&i^mouse_item^>=0/i^mouse_item^<=4/i^mouse_action^=(MOUSE_LMB_PRESSED)/i^key_shift^;
!!UN:P880/?(wogOption:y);
!!FU&(wogOption)<>(TRUE):E;

!!FU(ES_880_WriteSpellToSpellBook):P;

**********************
**** Set Up hooks ****
**********************

!?FU(OnStartOrLoad);
!!SN:L^erm_hooker.era^/?(ermHooker:y);
!!FU&(ermHooker)=0:E;

!!SN:A(ermHooker)/^SetHook^/?(address:y);
!!FU(ES_CreateERMHook):P(address:y);

!?FU(ES_CreateERMHook);

!#VA(address:x);

!!SN:E(address)/1/4462998/(ES_HOOK_AfterAttackMainFunc); [Trigger after melee attack, before retaliation]
!!SN:E(address)/1/4455129/(ES_HOOK_AfterAttackMainFunc); [Trigger after shooting]
!!SN:E(address)/1/5144585/(ES_OnGetHillFortCreatureLevel); [Trigger on getting creature levels at Hill Forts]
!!SN:E(address)/1/5893984/(ES_OnPlayerChooseSpell); [Trigger on player choosing a spell on the battlefield]

!!SN:E(address)/1/5008601/(ES_EndOfTurn);                     [trigger on every player end of turn]
!!SN:E(address)/1/5008923/(ES_EndOfTurn_AfterAutoSave);       [trigger on every player end of turn after autosave stuff]

!!UN:P879/?(isCaptureObjOpt:y);

!!if&(isCaptureObjOpt);
  !!SN:E(address)/1/4864048/(ES_OnPlayerVisit_MystGarden); [Trigger on player visiting Mysticism Garden]
  !!SN:E(address)/1/4880976/(ES_OnPlayerVisit_WaterWheel); [Trigger on player viisiting Water Wheel]
  !!SN:E(address)/1/4881456/(ES_OnPlayerVisit_WindMill); [Trigger on player visiting Wind Mill]
!!en;

!!SN:E(address)/1/4445639/(ES_HOOK_AfterStackInitParams); [Trigger after initialising the stats of a stack on the battlefield]

!?FU(ES_HOOK_AfterAttackMainFunc);      [by igrik]
!!SN:X?(hook:y);
!!UN:C(hook)/0/(UNC_INT)/?(stackStrucktDefender:y);   
!!UN:C(hook)/4/(UNC_INT)/?(stackStrucktAttacker:y);  
!!BG:A?(typeAttack:y);
!!VR(stackAttackerID:y):S(NO_STACK); 
!!VR(stackDefenderID:y):S(NO_STACK); 

!!if&(stackStrucktAttacker)<>(FALSE); 
  !!UN:C(stackStrucktAttacker)/244/(UNC_INT)/?(attakerSide:y); 
  !!UN:C(stackStrucktAttacker)/248/(UNC_INT)/?(attakerStackIdInSide:y);
  !!VR(stackAttackerID):S(attakerSide) *(BATTLE_STACKS_PER_SIDE) +(attakerStackIdInSide); 
!!en;

!!if&(stackStrucktDefender)<>(FALSE);
  !!UN:C(stackStrucktDefender)/244/(UNC_INT)/?(defenderSide:y);
  !!UN:C(stackStrucktDefender)/248/(UNC_INT)/?(defenderStackIdInSide:y);
  !!VR(stackDefenderID):S(defenderSide) *(BATTLE_STACKS_PER_SIDE) +(defenderStackIdInSide);
!!en;

!!FU(ES_OnAfterMelee)&(typeAttack)=(BATTLE_ACTION_WALK_AND_ATTACK):P(stackAttackerID)/(stackDefenderID);
!!FU(ES_OnAfterShoot)&(typeAttack)=(BATTLE_ACTION_SHOOT):P(stackAttackerID)/(stackDefenderID);
!!FU(ES_OnAfterAttack)|(typeAttack)=(BATTLE_ACTION_WALK_AND_ATTACK)/(typeAttack)=(BATTLE_ACTION_SHOOT):P(stackAttackerID)/(stackDefenderID);

!?FU(ES_HOOK_AfterStackInitParams);
!#VA(address:x);

!!UN:C(address)/(STRUCT_HOOK_CONTEXT_EBX)/4/?(stackStruct:y) C(stackStruct)/244/4/?(side:y) C(stackStruct)/248/4/?(stackPerSide:y);
!!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackPerSide);
!!FU(ES_BattleStack_InitParams):P(stack);

************************************
**** Set up object repalcements ****
************************************
; Warning: This must be executed later than Function for getting artifacts of different levels
!?FU(OnAfterErmInstructions);
; deleting the sound in the delete object function
; because it causes a crash
!!UN:C4893167/2/?(patch:y);
!!UN:C4893167/2/24555;
; get size of the map
!!UN:X?(mapSize:y)/?(hasUnderground:y);

; pass once through all cells of the map
!!re l/0/(hasUnderground);    coord z
  !!re k/0/(mapSize)/1/-1;    coord y
    !!re i/0/(mapSize)/1/-1;  coord x
      !!OBi/k/l:T?(objType:y) U?(objSubtype:y);
      !!TRi/k/l:E?(isYellowSquare:y) P?(isPassable:y); 
      !!VR(isYellowSquare):X1;  reverse param isYellowSquare
      !!FU(ES_OnIterateAllMapObjects):Pi/k/l/(objType)/(objSubtype)/(isYellowSquare)/(isPassable);
    !!en;
  !!en;
!!en;
; restoring the source code of the sound
; in the delete objects function
!!UN:C4893167/2/(patch);

*******************
**** Functions ****
*******************

// Get the string of an object owner
!?FU(ES_GameMgr_GetObjOwnerStr);
; string returns to global s^result^
; x1 - owner id
; x2 - owner text
!#VA(owner:x) (string:x);
!!if&(owner)>=(PLAYER_FIRST)/(owner)<=(PLAYER_LAST):;  
  !!VR(offset:y):S(owner) *4 +6969600; 
  !!UN:C(offset)/4/?(ptrOwnerName:y);
  !!SN:B(ptrOwnerName)/d/?(str:z);
  *!IF:L^%(@str)^;
  !!VR(string):Z(str);
!!en;

!?FU(ES_EraseFirstLine);
!#VA(string:x) (result:x);
!!VRz1:Sz(string);
!!SN:Kz1/?(len:y);
!!re i/0/(len:y)/1/-1;
  !!SN:Kz1/i/?(char:z);
  !!if&(char)=^%T(es.endl)^;
    !!VR(newLen:y):S(len) -i;
    !!VR(newStr:z):M1/z1/i/(newLen);
    !!VR(result):Z(newStr);
    !!br;
  !!en;
!!en;


!?FU(ES_Hero_GetFullSpellPoints);
!#VA(hero:x) (result:x);

!!HE(hero):Z?(heroStruct:y);            [get hero structure]
!!UN:C(heroStruct)/1145/1/?(knowledge:y);(get hero knowledge]
!!SN:E5131040/(CALLCONV_THISCALL_FLOAT)/(heroStruct); [get Intelligence power]
!!VRe1:*10 *(knowledge);                [e1, emul to get max SP]
!!VR(result):Se1;                       [return max hero SP]


// Get a monster's rank with its experience
; Returns R11 as R10
!?FU(ES_GetMonRankWithExp);             [by Hawaiing]
!#VA(mon:x) (exp:x) (rank:x);

; Get the exp of R11
!!EA(mon):L?(monExpR10:y) P?(monExpTop:y);
!!VR(monExpR11:y):S(monExpR10) +(monExpTop);

!!if&(exp)=(monExpR11);
  !!VR(rank):S11;
!!el;
  !!SN:E7503648/1/(mon)/(exp);
  !!VR(rank):Sv1;
!!en;

// Get the coordinates by battle position
!?FU(ES_GetBattleHexCoordinates);       [by Hawaiing]
!#VA(position:x) (x:x) (y:x);

!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(value:y);
!!VR(value2:y):S(position) *112;
!!VR(value3:y):S(value2) +(value) +452; [coordinate structure]
!!VR(xAddress:y):S(value3) +4; 
!!UN:C(xAddress)/(UNC_INT16)/?(x);      [x coordinate]
!!VR(yAddress:y):S(value3) +6; 
!!UN:C(yAddress)/(UNC_INT16)/?(y);      [y coordinate]

// Calculate distance between two hexes
!?FU(ES_CalcDistanceBetweenHexes);      [by wessonsm]
!#VA(hex1:x) (hex2:x) (distance:x);

!!VR(x1:y):S(hex1) %17;
!!VR(y1:y):S(hex1) :17;
!!VR(x2:y):S(hex2) %17;
!!VR(y2:y):S(hex2) :17;
!!VR(distanceY:y):S(y1) -(y2);
!!VR(distanceY)&(distanceY)<0: *-1;
!!VR(x1):*2;
!!VR(y1):&1;
!!VR(x2):*2;
!!VR(y2):&1;
!!VR(distanceX:y):S(x1) -(y1) -(x2) +(y2);
!!VR(distanceX)&(distanceX)<0:*-1;
!!VR(distanceX):-(distanceY);
!!VR(distance):S(distanceX);
!!VR(distance)&(distance)<0:S0;
!!VR(distanceY):*2;
!!VR(distance):+(distanceY) :2;

// Turn a stack around
!?FU(ES_TurnStackAround);              [by Hawaiing]
!#VA(stack:x);

!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(value:y);
!!VR(value2:y):S(stack) *1352 +21708 +(value);
!!SN:E4482112/2/(value2)/1;

// Initiate a melee attack
!?FU(ES_BattleStack_MeleeAttack);       [by Hawaiing]
!#VA(atkStack:x) (defStack:x);
!#VA(direction:x);                      [0 for upper, 1 for forward and 2 for lower]

!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(value:y);
!!VR(value2:x):S(atkStack) *1352 +21708 +(value);
!!VR(value3:x):S(defStack) *1352 +21708 +(value);
!!SN:E4461360/2/(value2)/(value3)/(direction);

// Get town ID in the same position of a hero
!?FU(ES_Hero_GetTownId);                [by daemon_n]
!#VA(heroId:x) (townId:x);

!!VR(townId):S(NO_TOWN);
!!HE(heroId:x):P?(hX:y)/?(hY:y)/?(hZ:y);

!!if&(hX)>=0;
  !!VR(x:y):S(hX) -1;
  !!VR(y:y):S(hY);
  !!VR(z:y):S(hZ);
  !!UN:U(OBJ_TOWN)/(ANY_OBJ)/-1/(x)/(y)/(z);

  !!if&(x)=(hX)/(y)=(hY)/(z)=(hZ);
    !!CA(x)/(y)/(z):U?(townId);
  !!en;
!!en;



// Check if it is allowed to build the building in the town
!?FU(ES_CheckBuildingEligibility);      [by igrik]
!#VA(townId:x);                         [town number on map (0...47)]
!#VA(building:x);                       [building id]
!#VA(result:x);                         [return: bool (0-no, 1-yes)]

!!VR(result):S(FALSE);   
!!FU(ES_GetTownStruct):P(townId)/?(ptr:y);
!!CA0/(townId):R?(isbuilt:y) R(FALSE);
!!SN:E6033696/2/(ptr)/(building);
!!VR(result)&v1<>(FALSE):S(TRUE);
!!CA0/(townId):R(isbuilt);


; Get city structure
!?FU(ES_GetTownStruct);
!#VA(townId:x);                         [Town number on map (0...47)]
!#VA(ptr:x);                            [Return: ptr structure town]
 
!!IF&(townId)<=(NO_TOWN)|(townId)>47:M^Wrong town id.^;
!!UN:C6919480/(UNC_INT)/?(value:y); 
!!VR(value):+136724;
!!UN:C(value)/(UNC_INT)/?(value2:y); 
!!VR(ptr:x):S(townId) *360 +(value2);
!!IF&(ptr)<43200000:M^{Attention!}
Error in getting town structure address. 
The game may fall at any time.^; 

!?FU(ES_UnPackedCoords);
; ?x1, ?x2, ?x3 - return unpacked coords (x/y/z)
; x4 - packed coords
!#VA(x:x) (y:x) (z:x) (coords:x); 
!!SN:E7413577/1/?(x)/?(y)/?(z)/(coords);

!?FU(ES_AdvMgr_GetMapItem);
; x1, x2, x3 - coords (x/y/z)
;?x4 - return MapItem structure
!#VA(x:x) (y:x) (z:x) (mapItem:x); 

!!UN:C(ADV_MANAGER)/(UNC_UINT32)/?(am:y);
!!UN:C(am)/92/(UNC_UINT32)/?(list:y);
!!SN:E4228816/2/(list)/(x)/(y)/(z);
!!VR(mapItem):Sv1;

// Get a random unoccupied hero
!?FU(ES_GetRandomUnoccupiedHero);       [by Archer30]
!#VA(randHero:x);                       [Out. Random Hero number]
!#VA(player:x);                         [Optional. Check whether the player is eligible to recruite the hero. value other than -1 ~ 7 would skip the check]

; Standarise variables
!!FU:A?(numArgs:y);
!!VR(player)&(numArgs)<2:S-2;
!!VR(player)&(player)<(ANY_PLAYER)/(player)>(PLAYER_LAST):S-2;

!!if&(player)>-2;
  !!if&(player)>(ANY_PLAYER);
    !!VR(playerBits:y):S1 Sd<<(player);
  !!el;
    !!VR(playerBits):S255;
  !!en;
!!en;

!!VR(randHero):S(NO_HERO);

; Check if Hourglass of Asmodeus is enabled
!!UN:P56/?(hourglassOn:y);

!!FU(NewIntArray):P?(availHeroes:y);

; Loop through all the heroes
!!re i/(HERO_FIRST)/(HERO_LAST_WOG);
  ; Skip if the hero is Asmodeus (When Hourglass of Asmodeus is enabled)
  !!co&(hourglassOn)/i=i^wog_106_Asmodeus^;

  ; Skip if the hero is not allowed for the player
  !!if&(player)>-2;
    !!HEi:R3/?(isEnabled:y)/(playerBits);

    !!co&(isEnabled)<>(TRUE);
  !!en;

  ; Check if the hero has an owner or is in a prison
  !!HEi:O?(owner:y) P?(x:y)/?(y:y)/?(z:y);

  ; Check if the hero is in a tavern if both no owner and not in a prison
  !!if&(owner)=(NO_OWNER)/(x)<0/(y)<0/(z)<0;

    !!re j/(PLAYER_FIRST)/(PLAYER_LAST);
      !!OW:Vj/?(leftHero:y)/?(rightHero:y);

      !!br&i=(leftHero);
      !!br&i=(rightHero);
    !!en;

      ; Push the hero to the available heroes array if all the criteria are matched
    !!FU(Array_Push)&j>(PLAYER_LAST):P(availHeroes)/i;
  !!en;
!!en;

; Get the random hero from the array
!!SN:M(availHeroes)/?(size:y);

!!if&(size)>0;
  !!VR(lastIndex:y):S(size) -1;
  !!VR(random:y):R0/0/(lastIndex);
  !!SN:M(availHeroes)/(random)/?(randHero);
!!en;

// Resouces check and reduce for a given player
!?FU(ES_Player_CheckEnoughResources);   [by Archer30]
; Check if a player has enough for all the given amount of resources.

; Supports two call syntaxes:
;   P(result)/(player Id)/(wood)/(mercury)...
;   P(result)/(player Id)/(ID of dynamical array, containing resounce amount)

; Resouces must be provided with this sequence: Wood, Mercury, Ore, Sulfur, Crystal, Gems, Gold and Mithril (optional)
!#VA(result:x) (playerId:x) (thirdArg:x);

!!VR(result):S(FALSE);

!!FU:A?(numArgs:y);
; Exit if invalid amount of parameters
!!FU&(numArgs)<=2:E;

!!UN:P36/?(mithrilEnabled:y);

!!if&(numArgs)>(@thirdArg);
  !!VR(lastResInd:y):S(numArgs) -(@thirdArg);
  !!VR(lastResInd)&(mithrilEnabled)/(numArgs)>=10:S(RES_MITHRIL);

  !!re i/(RES_FIRST)/(lastResInd);
    !!VR(argPtr:y):Si +3;               [The definition of resources amount starts from x3]
    !!OW:R(playerId)/i/?(count:y);
    !!VR(count):-x(argPtr); 
    !!FU&(count)<0:E;
  !!en;
!!el;
  !!SN:M(thirdArg)/?(size:y);

  !!VR(lastResInd):S(size) -1;
  !!VR(lastResInd)&(mithrilEnabled)/(size)>=8:S(RES_MITHRIL);

  !!re i/(RES_FIRST)/(lastResInd);
    !!SN:M(thirdArg)/i/?(cost:y);
    !!OW:R(playerId)/i/?(count);
    !!VR(count):-(cost);
    !!FU&(count)<0:E;
  !!en;
!!en;

!!VR(result):S(TRUE);

; -----------------------------------

!?FU(ES_Player_RemoveResources);        [by Archer30]
; Remove resouces from a given player, prevent any value to be negative.

; Supports two call syntaxes:
;   P(player Id)/(wood)/(mercury)...
;   P((player Id)/ID of dynamical array, containing resounce amount)

; Resouces must be provided with this sequence: Wood, Mercury, Ore, Sulfur, Crystal, Gems, Gold and Mithril (optional)
!#VA(playerId:x) (secondArg:x);

!!FU:A?(numArgs:y);
; Exit if invalid amount of parameters
!!FU&(numArgs)<=1:E;

!!UN:P36/?(mithrilEnabled:y);

!!if&(numArgs)>(@secondArg);
  !!VR(lastResInd:y):S(numArgs) -(@secondArg);
  !!VR(lastResInd)&(mithrilEnabled)/(numArgs)>=9:S(RES_MITHRIL);

  !!re i/(RES_FIRST)/(lastResInd);
    !!VR(argPtr:y):Si +2;               [The definition of resources amount starts from x2]
    !!OW:R(playerId)/i/?(count:y);
    !!VR(count):-x(argPtr) F0/(INT_MAX); 
    !!OW:R(playerId)/i/(count);
  !!en;
!!el;
  !!SN:M(secondArg)/?(size:y);

  !!VR(lastResInd):S(size) -1;
  !!VR(lastResInd)&(mithrilEnabled)/(size)>=8:S(RES_MITHRIL);

  !!re i/(RES_FIRST)/(lastResInd);
    !!SN:M(secondArg)/i/?(cost:y);
    !!OW:R(playerId)/i/?(count);
    !!VR(count):-(cost) F0/(INT_MAX);
    !!OW:R(playerId)/i/(count);
  !!en;
!!en;

// Get the total exp required for reaching a hero level
!?FU(ES_GetExpRequirementOfLevel);      [by daemon_n]
!#VA(lvl:x) (exp:x);

!!VR(exp):S0;
!!FU&(lvl)<1:E;
!!VR(saveV1:y):Sv1;
!!SN:E5088784/(CALLCONV_FASTCALL)/(lvl:x);
!!VR(exp):Sv1;
!!VRv1:S(saveV1);


!?FU(ES_IfHexIsFree);
!#VA(pos:x) (isFree:x);

!!VR(isFree):S(TRUE);
!!VR(posX:y):S(pos) %17;

!!if|(pos)<0/(pos)>186/(posX)=0/(posX)=16;
  !!VR(isFree):S(FALSE);
!!en;

!!if&(isFree);
  !!BU:E(pos)/?(stack:y) O(pos)/?(obstacleFlag:y);
  !!VR(isFree)|(stack)>(NO_STACK)/(obstacleFlag)>0:S(FALSE);
!!en;

!!if&(isFree);
  !!UN:C(COMBAT_MANAGER)/4/?(battleMgr:y);
  !!SN:E4626848/2/(battleMgr)/(pos)/0;  defensive moat
  !!VR(isFree)&v1=1:S(FALSE);
  !!SN:E4625904/2/(battleMgr)/(pos);  if position prohibited
  ; needed for positions 95 and 96 near the town gate
  !!VR(isFree)&v1=1:S(FALSE);
!!en;

// Get the active hero of the given player
!?FU(ES_GetPlayerActiveHeroesList);     [by daemon_n]
!#VA(playerID:x) (array:x);

!!VR(array):S0;

!#VA(hero[8]:y);
!!OW:O(playerID)/?(heroesOnMap:y)/?(hero[0])/?(hero[1])/?(hero[2])/?(hero[3])/?(hero[4])/?(hero[5])/?(hero[6])/?(hero[7]);

!!if&(heroesOnMap)>0;
  !!FU(NewIntArray):P(heroesOnMap)/?(array);

  !!re i/0/(heroesOnMap)/1/-1;
    !!SN:M(array)/i/(hero[i]);
  !!en;
  
  !!SN:F^ExtendArrayLifetime^/(array);
!!en;

// Calculate number of secondary skills a hero have
; Usually this funciton is not needed if everything sets correctly. The number can be fetched by HE:S?#1
!?FU(ES_CalcNumberOfSecSkills);         [by Archer30]
!#VA(hero:x) (number:x);

!!VR(number):S0;
!!VR(warfarePlaced:y):S(FALSE);

!!re i/(SEC_SKILL_FIRST)/(SEC_SKILL_LAST);
  !!HE(hero):Si/?(learned:y);

  !!if&(learned);
    !!if|i=(SKILL_BALLISTICS)/i=(SKILL_ARTILLERY)/i=(SKILL_FIRST_AID);
      !!if&i^wog_193_enabled^;
        !!if&(warfarePlaced:y)=(FALSE);
          !!VR(warfarePlaced:y):S(TRUE);
          !!VR(number):+1;
        !!en;

        !!co;
      !!en;
    !!en;

    !!VR(number):+1;
  !!en;
!!en;

// Remove artifact from a given slot
; This function is needed as FU(UnequipArtFromSlot) cannot be used to remove artifact from the backpack. 
!?FU(ES_RemoveArtFromSlot);             [by Archer30]
!#VA(hero:x) (slot:x);

!!FU&(slot)<=(NO_ART_SLOT):E;

; Execute FU(UnequipArtFromSlot) if the artifact is equipped
!!if&(slot)<=18;
  !!FU(UnequipArtFromSlot):P(hero)/(slot);
; Use HE:A if the artifact is in the backpack
!!el;
  !!HE(hero):A1/?(art:y)/(slot);
  !!HE(hero):A3/(art)/1/0;
!!en;
