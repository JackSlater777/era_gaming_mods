ZVSE2
; gem_functions.erm
; version 1.00
; author: daemon_n.

********************************Add Own Button In Town Menu Dialog**********************************
Allows to add own inTown interaction via Custom Dialog i ve made
You need set .def of the button -- recomend size is 66x32 px
buttons are added one by one, depend on the called "gem_AddTownButton" function amount
!#DC(GEM_MON_ATTACK_DEFAULT) = 0;
!#DC(GEM_MON_ATTACK_MELEE) = 1;
!#DC(GEM_MON_ATTACK_SHOOT) = 2;
!#DC(GEM_MON_ATTACK_CAST) = 3;
!#DC(GEM_MON_ATTACK_WALK) = 4;
!#DC(GEM_MON_ATTACK_RETURN) = 5;
!#DC(GEM_MON_ATTACK_STAY) = 6;

!?FU(OnGameEnter);
!!UN:C4633296/1/51 C4633292/1/44;       [surrender btn xPos and width 2001]
!!UN:C4633429/1/98 C4633425/1/44;       [retreat btn xPos and width 2002]
!!UN:C4633558/1/44;                     [systemOpt btn width 2003]
!!UN:C4633695/1/145 C4633691/1/44;      [autoBattle btn xPos and width 2004]
!!UN:C4634632/4/194 C4634625/4/391;     [log pcx xpos 2005]

!!UN:C4634751/4/590 C4634904/4/590;     [arrow btns up and down xPos 2006, 2007]

!!UN:C4633831/4/611 C4633827/1/44;      [spellBook btn xPos and width 2008]
!!UN:C4633967/4/705 C4633963/1/44;      [wait btn xPos and width 2009]
!!UN:C4634103/4/752 C4634099/1/44;      [defend btn xPos and width 2010]

!!UN:C4635680/4/192;                    [NEXT CREATURE btn xPos 2300]
!!UN:C4635792/4/392;                    [START BATTLE btn xPos 30722]

!?FU(gem_OnPlaceBattleBttns);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/(UNC_INT)/?(ebp:y) C(ebp)/8/(UNC_INT)/?(dlg:y);
  !!SN:F^GetButtonID^/^gem_alt_btn^;
  !!if&v1/(dlg);
    !!VRi^gem_battle_altbttn_id^:Sv1;
    !!VRi^gem_battle_dlg^:S(dlg);
    !!UN:P(WOG_OPT_STACK_EXPERIENCE)/?i^gem_opt%(WOG_OPT_STACK_EXPERIENCE)^;
    !!FU(gem_DlgItemPosition):P2/194/d-1/d/(dlg);                           [set input chat position and size]
    !!FU(gem_DlgItemSize):P2/391/d/d/(dlg);
    !!if&i^gem_battle_StackAbilities_ArrayId^=0;
      !!SN:M(M_AUTO_ID)/0/(M_INT)/(M_TEMP)/?i^gem_battle_StackAbilities_ArrayId^;(abils:y);
    !!en;
  !!en;



!?FU(gem_BattleBtn_Proc);
!#VA(stackId:x) (side:x) (obtainedTurn:x);
  !!BA:Q?(isQuick:y);

  !!if&(isQuick)=(FALSE);
    !!BU:T?(isTacticks:y);

    !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y) C(cmbMgr)/78532/(UNC_INT)/?(isAuto:y);
    !!if&(isAuto)=(FALSE);

      !!OW:Cd/?(clickedPlayer:y);

      !!if&i^battle_isNetwork^=(FALSE)/i^battle_humanOnly^;
        !!VR(clickedPlayer):Si^battle_owner_%(side)^;
      !!en;

      !!if&i^battle_owner_%(side)^=(clickedPlayer)/i^gem_BattleBtn_StackBits^;
          !!FU(gem_DlgDisableBtn):Pi^gem_battle_altbttn_id^/(TRUE);           [enable bttn]

          !!if&(obtainedTurn)/i^gem_BattleBtn_StackChoice_%(stackId)^/i^gem_BattleBtn_StackBits_old_%(stackId)^=i^gem_BattleBtn_StackBits^;
            !!VRi^gem_BattleBtn_CurrentAbility^:Si^gem_BattleBtn_StackChoice_%(stackId)^;  if obtained turn + was choice before + possible to repeat]

          !!en;

          !!FU(gem_BattleBtn_GetNextAbility):Pi^gem_BattleBtn_CurrentAbility^/?(nextAbility:y);
          *!IF:L^%(nextAbility)^;
          !!if&(obtainedTurn)=(FALSE);
            !!VRi^gem_BattleBtn_CurrentAbility^:S(nextAbility);
            !!FU(gem_BattleBtn_GetNextAbility):Pi^gem_BattleBtn_CurrentAbility^/?(nextAbility);
          !!en;

          !!FU(gem_BattleBtn_AffectCreature):P(stackId)/i^gem_BattleBtn_CurrentAbility^;

          !!VR(frame:y):S(nextAbility) *3;
          !!SN:E4684800/(CALLCONV_THISCALL)/(cmbMgr); [(recalc all stack properies ) -makes all the game needs]
          !!SN:E4797616/(CALLCONV_THISCALL)/(cmbMgr)/0/1; [redraw grid]

          !!VR(whenPressedFrame:y):S(frame) +1; !!VR(whenDisabledFrame:y):S(frame) +2;
          !!FU(gem_DlgDefProc):Pi^gem_battle_altbttn_id^/(frame)/(whenPressedFrame)/(whenDisabledFrame); [set def frame]

          !!if&i^mouse_battleHex^=>0/i^mouse_battleHex^<=(BATTLE_HEX_LAST);
            !!SN:E4800272/(CALLCONV_THISCALL)/(cmbMgr)/i^mouse_battleHex^/i^mouse_battleHex^;    [refresh shadow under mouse]
          !!en;

      !!el&i^battle_owner_%(side)^=(clickedPlayer);

        !!FU(gem_DlgDisableBtn):Pi^gem_battle_altbttn_id^/(FALSE)/0;/(currentFrame)/d/i^gem_battle_dlg^;
        !!SN:E6288864/2/i^gem_battle_dlg^/1/i^gem_battle_altbttn_id^/i^gem_battle_altbttn_id^; [refresh btn]

      !!el;
        !!FU(gem_DlgDisableBtn):Pi^gem_battle_altbttn_id^/(FALSE);/(currentFrame)/d/i^gem_battle_dlg^;
      !!en;

      !!SN:E6288864/2/i^gem_battle_dlg^/1/i^gem_battle_altbttn_id^/i^gem_battle_altbttn_id^; [refresh btn]

    !!el;
      *!FU(gem_DlgDefProc):Pi^gem_battle_altbttn_id^/?(currentFrame:y)/d/(FALSE)/i^gem_battle_dlg^;
      *!VR(currentFrame):+2;
      !!FU(gem_DlgDisableBtn):Pi^gem_battle_altbttn_id^/(FALSE);/(currentFrame)/d/i^gem_battle_dlg^;
      !!SN:E6288864/2/i^gem_battle_dlg^/1/i^gem_battle_altbttn_id^/i^gem_battle_altbttn_id^; [refresh btn]
    !!en;
  !!en;

*?FU(onbale);
*?BG;

*!IF:L^%^;
!?FU(gem_OnBeforeHarpyTryMoveBack)&i^gem_BattleBtn_CurrentAbility^=(GEM_MON_ATTACK_STAY);
  !!UN:C4478599/2/4/0;                  [break move back ability]

!?FU(gem_OnAfterHarpyTryMoveBack)&i^gem_BattleBtn_CurrentAbility^=(GEM_MON_ATTACK_STAY);
  !!UN:C4478599/2/4/187;                [restore move back ability]

!?FU(gem_BattleBtn_AffectCreature);
!#VA(stackId:x) (ability:x);
*!IF:L^%(ability)^;
  !!if&(ability)=(GEM_MON_ATTACK_SHOOT);
    !!BM(stackId):E0 U3/i^gem_stack_shoots^;
    !!VRi^gem_need_to_restore_shoots^:S(FALSE);
    !!VRi^gem_need_to_restore_spells^:S(TRUE);

  !!el|(ability)=(GEM_MON_ATTACK_MELEE)/(ability)=(GEM_MON_ATTACK_WALK); 
    !!BM(stackId):E0 U3/0;
    !!VRi^gem_need_to_restore_shoots^:S(TRUE);
    !!VRi^gem_need_to_restore_spells^:S(TRUE);

  !!el&(ability)=(GEM_MON_ATTACK_CAST);
    !!BM(stackId):Ei^gem_stack_spells^ U3/(NULL);
    !!VRi^gem_need_to_restore_shoots^:S(TRUE);
    !!VRi^gem_need_to_restore_spells^:S(FALSE);
  !!en;

  !!if&i^gem_stack_do_not_affect_spells^;
    !!BM(stackId):Ei^gem_stack_spells^;
    !!VRi^gem_need_to_restore_spells^:S(FALSE);
  !!en;


!?FU(gem_BattleBtn_GetNextAbility);
!#VA(currentAbility:x) (nextAbility:x);

  !!VR(firstAbility:y):S0;
  !!VR(thisAbilityReached:y):S(FALSE);
  !!VR(nextAbility):S0;
  *!IF:L^%(currentAbility)^;
  !!re j/1/6;
    !!VRi:S1 Sd<<j;
    !!VR(bitCheck:y):Si^gem_BattleBtn_StackBits^ &i; [check bits]
    *!IF:M^%j %(currentAbility) %(firstAbility) %(nextAbility) %(thisAbilityReached)^;
    !!if&j=(currentAbility);
       !!VR(thisAbilityReached):S(TRUE);
    !!el&(bitCheck);
      !!if&(thisAbilityReached);  [check if we passed current ability in loop]

        !!VR(nextAbility):Sj;
        !!FU:E;                 //EXIT FUNCTION
      !!el&(firstAbility)=0; 
        !!VR(firstAbility:y):Sj;;
      !!en;
    !!en;
  !!en;

  !!VR(nextAbility):S(firstAbility);



// 0 nothing 0
// 2 melee 1
// 4 shoot 2 
// 8 cast  3
// 16 walk 4
// 32 attack and back 5
// 64 attack and stay 6
!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED)/i^mouse_item^=2009;
    *!CM:R(FALSE); [disable defend bttn stnadard reaction]
    *!SS(SPELL_PROTECTION_FROM_FIRE):O?y1;
    *!BMi^battle_current_stack^:Z?(stack:y) U4/?y22;
    *!VR(size:y):S1;
    *!re i/1296/1319/(size);
      *!UN:C(stack)/i/(size)/?(spell:y);
      *!IF&(spell)>=(SPELL_FIRST_BATTLE)/(spell)<=(SPELL_LAST_BATTLE):L^ (spell) %i %(spell)^;
    *!en;

    *!IF:L^%y22^;
331
!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED)/i^mouse_item^=2010;
    !!CM:R(FALSE); [disable defend bttn stnadard reaction]
    !!FU(gem_GetTxtTableString):P6976896/387/1/?(text:z);
    !!IF:M0/4^%(text)^;

!?FU(gem_BattleBtn_CollectStackFlags);
!#VA(stackId:x);

  !!BM(stackId):F?f E?i^gem_stack_spells^ U3/?i^gem_stack_shoots^ T?t O?(heroStack:y);
  !!VRi^gem_BattleBtn_StackBits^:S0;
  !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_DEFAULT);
  !!VRi^gem_stack_do_not_affect_spells^:S0;

  !!if&t>=(MON_CATAPULT)/t<=(MON_ARROW_TOWERS);
    !!FU:E;
  !!en;

  !!if&t>=(MON_COMMANDER_FIRST_A)/t<=(MON_COMMANDER_LAST_D);
    !!COi^battle_hero_0^:B1/4/?(shooting:y);
    !!if&(shooting);
      !!BM(stackId):Fd|(MON_FLAG_SHOOTER);
    !!en;
  !!en;

  !!VRf:&(MON_FLAG_SHOOTER);
  !!if|f/i^gem_stack_shoots^;
    !!BM(stackId):Z?(stack:y);
    !!SN:E4466192/(CALLCONV_THISCALL)/(stack)/0;
    !!if&v1=(TRUE);
      !!VRi^gem_BattleBtn_StackBits^:|(BIT_1) |(BIT_2);
      !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_SHOOT);
    !!en;
  !!en;

  !!if&i^gem_stack_spells^;

    !!if&t=(MON_FAERIE_DRAGON);
      !!VRi^gem_BattleBtn_StackBits^:|(BIT_1)  |(BIT_3);
      !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_CAST);
    !!el;
      !!BM(stackId):Z?(stack:y) U4/?(spell:y);
      !!SS(spell):O?(target:y);

      !!if&(target)=-1;                     [if spell target = hostile troop]
        !!VRi^gem_BattleBtn_StackBits^:|(BIT_1)  |(BIT_3);
        !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_CAST);
      !!el;                                                        [if spell target = any(empty) hex]
        !!VRi^gem_stack_do_not_affect_spells^:S(TRUE);

        !!re i/0/(BATTLE_HEX_LAST);
          !!SN:E4485360/(CALLCONV_THISCALL)/(stack)/i;                 [(if can cast any(empty) hex)]
          !!if&v1;
            !!VRi^gem_BattleBtn_StackBits^:|(BIT_3)  |(BIT_4);
            !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_CAST);
            !!VRi^gem_stack_do_not_affect_spells^:S(FALSE);
            !!br;
          !!en;
        !!en;

      !!en;
    !!en;

  !!en;

  !!if&i^battle_isNetwork^=(FALSE);
    !!if|t=(MON_HARPY)/t=(MON_HARPY_HAG)/t=(MON_DARKNESS_DRAGON);
      !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_RETURN);
      !!VRi^gem_BattleBtn_StackBits^:|(BIT_5)  |(BIT_6);
    !!el&i^gem_opt%(WOG_OPT_STACK_EXPERIENCE)^/(heroStack)<>(NO_STACK);
      !!BM:I?(side:y);
      !!HEi^battle_hero_%(side)^:C0/(heroStack)/d/d/?(lvl:y)/12 C0/(heroStack)/d/d/(lvl)/12; [necessary to repeat cause of bug]

      !!VR(eaStack:y):S(stackId) +1 *-1;
      !!EA(eaStack):F102/98/?(abLine:y);
      !!if&(abLine);
        !#VA(abVal[11]:y);
        !!EA(eaStack):B(abLine)/?(isEnabled:y)/?(type:y)/?(subType:y)/?(abVal[0])/?(abVal[1])/?(abVal[2])/?(abVal[3])/?(abVal[4])/?(abVal[5])/?(abVal[6])/?(abVal[7])/?(abVal[8])/?(abVal[9])/?(abVal[10]);
        !!if&(isEnabled)=(TRUE)/(type)=102/(subType)=98/(abVal[lvl])=(TRUE);
          !!VRi^gem_BattleBtn_StackBits^:|(BIT_5)  |(BIT_6);
          !!VRi^gem_BattleBtn_CurrentAbility^:S(GEM_MON_ATTACK_RETURN);
        !!en;

      !!en;
    !!en;
  !!en;

  *!VR(flagsBitSet):Si^gem_BattleBtn_StackBits^;

!?FU(OnBattleStackObtainsTurn);&i^battle_isVisible^/i^battle_isQuick^=(FALSE);
  !!FU(gem_BattleBtn_CollectStackFlags):Pi^battle_current_stack^;
  !!FU(gem_BattleBtn_Proc):Pi^battle_current_stack^/x1/(TRUE);

!?FU(OnBattleScreenMouseClick)&i^mouse_action^=(MOUSE_LMB_RELEASED)/i^mouse_item^=i^gem_battle_altbttn_id^/i^gem_BattleBtn_StackBits^;
  !!BG:Q?(actSide:y);
  !!FU(gem_BattleBtn_Proc):Pi^battle_current_stack^/(actSide)/(FALSE);

!?FU(OnBattleActionEnd)&i^gem_battle_altbttn_id^;
  !!BG:A?(actionType:y);
  !!if&(actionType)=(BATTLE_ACTION_HERO_CAST);                               [if hero casts check the abilities]

    !!FU(gem_BattleBtn_RestoreAbilities):Pi^battle_current_stack^;
    !!FU(gem_BattleBtn_CollectStackFlags):Pi^battle_current_stack^;
    !!FU(gem_BattleBtn_Proc):Pi^battle_current_stack^/i^battle_current_side^/(TRUE);
  !!el&(actionType);
    !!FU(gem_BattleBtn_RestoreAbilities):Pi^battle_current_stack^;
  !!en;

!?FU(gem_BattleBtn_RestoreAbilities);
!#VA(stackId:x);
*!IF:L^%(stackId:x) %i(gem_need_to_restore_spells)^;
  !!if&i^gem_need_to_restore_shoots^;
    !!BM(stackId):U3/i^gem_stack_shoots^;
    !!VRi^gem_need_to_restore_shoots^:S0;
  !!en;
  !!if&i^gem_need_to_restore_spells^;
    !!BM(stackId):Ei^gem_stack_spells^;
    !!VRi^gem_need_to_restore_spells^:S0;
  !!en;

  !!VRi^gem_BattleBtn_StackChoice_%(stackId)^:Si^gem_BattleBtn_CurrentAbility^;
  !!VRi^gem_BattleBtn_StackBits_old_%(stackId)^:Si^gem_BattleBtn_StackBits^;

!?FU(OnAfterBattleUniversal)&i^gem_battle_dlg^;
!!FU(gem_BattleBtn_Dtor):P;
!?FU(OnBeforeBattleReplay)&i^gem_battle_dlg^;
!!FU(gem_BattleBtn_Dtor):P;

!?FU(gem_BattleBtn_Dtor);
  !!VRi^gem_battle_dlg^:S0;
  !!VRi^gem_battle_altbttn_id^:S0;
  !!VRi^gem_BattleBtn_CurrentAbility^:S0;
  !!VRi^gem_opt%(WOG_OPT_STACK_EXPERIENCE)^:S0;
  !!VRi^gem_BattleBtn_StackBits^:S0;
  !!VRi^gem_need_to_restore_spells^:S0;
  !!VRi^gem_need_to_restore_shoots^:S0;

  !!VRi^gem_stack_spells^:S0;
  !!VRi^gem_stack_shoots^:S0;

  !!re i/0/(BATTLE_STACK_LAST);
    !!VRi^gem_BattleBtn_StackChoice_%i^:S(NULL);
    !!VRi^gem_BattleBtn_StackBits_old_%i^:S(NULL);
  !!en;


!?FU(gem_OnOpenButtonDlg); 
Triggers when buttons been added. Occurs when Dialog being called;
Use this for adding your button;
You can only set!

;*!FU(gem_AddTownButton):P(z1)/(z2)/(z3)/(y1)/(y2)/(y3)/(y4); function of the btn adding
;(z1) = ^myOwnDef.def^ - Name of The .def file for the button;
;(z2) = ^textHintWhenMouseOver^ - contents Hint for the button in bottom part
;(z3) = ^RightCLickingText^ - PopUp message on the Right-CLicking on the your button
;(y1) = (FunctionNameToLaunch) - name of the function, use without symbols like (!FU) and (;)
;(y2) = optional integer 1st value for the your function launch, leave it empty, if not needed
;(y3) = optional integer 2nd value for the your function launch, leave it empty, if not needed
;(y4) = optional integer 3rd value for the your function launch, leave it empty, if not needed

!?FU(gem_OnOpenButtonDlg);&i^gem_TownScreenIsOpened^=1; 
  *!re i/0/13;
    *!VR(odd:y):R0/7/60;
    *!if&(odd);
      *!FU(gem_AddTownButton):P^smalres.def^/15/(odd)/^{~text align=left} what for %i  }^/^hint for me %i^/^text for me %i^/(gem_some_rand_fu)/i/2/1;

    *!el;
      *!FU(gem_AddTownButton):P^resource.def^/64/64/^{~text align=left} what for %i }^/^hint for me %i^/^rmb for me %i^/(gem_some_rand_fu)/i/1/2;
    *!en;
    *!FU(gem_AddTownButton):P^resource.def^/35/35/^hint for me1^/^text for me^/(gem_some_rand_fu)/0/0/1;
    *!FU(gem_AddTownButton):P^smalres.def^/35/15/^hint for me3^/^text for me^/(gem_some_rand_fu)/0/0/2;
    *!FU(gem_AddTownButton):P^resource.def^/35/35/^hint for me2^/^text for me^/(gem_some_rand_fu)/0/1/0;
    *!FU(gem_AddTownButton):P^smalres.def^/35/15/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/1/2;
  *!en;
  !!FU(gem_AddTownButton):P^artifact.def^/20/20/^123^/^321^/^456^/(MyNum)/(arg1:y)/(arg2:y)/(arg3:y);

  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/0;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/1;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/2;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/1/0/0;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/^gem_some_rand_fu^/4/5/6;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me1^/^text for me^/(gem_some_rand_fu)/4/5/6;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me3^/^text for me^/(gem_some_rand_fu)/4/5/6;
  *!VRi^gem_TownScreenIsOpened^:S2;

!?FU(gem_some_rand_fu);
  *!IF:L^%x1 %x2 %x3^;

!?FU(gem_CheckModFolderNameExists);         [that function get mod list in array from !FU(gem_GetModList) and compare each folder with]
!#VA(modNameForCheck:x) (isExist:x);
  !!VR(emptyStr:z):S^%z(modNameForCheck)^ H1;
  !!if|1/(emptyStr)=^^;        [show error if mod name is not string or empty]
    !!IF:M^{The mod name you are trying to check is incorrect!}^;
    !!FU:E;
  !!en;

  !!VR(textModNameForCheck:z):S^%z(modNameForCheck)^;
  !!FU(gem_GetModList):P?(modListArrayID:y)/?(modsAmount:y);

  !!FU(StrToLower):P(textModNameForCheck)/?(textModNameForCheck);

  !!re i/0/(modsAmount)/1/-1;
    !!SN:M(modListArrayID)/i/?(modName:z);
    !!FU(StrToLower):P(modName)/?(modName);

    !!if&(textModNameForCheck)=(modName);
      !!VR(isExist):S(TRUE);
      !!FU:E;    
    !!en;
  !!en;

  !!VR(isExist):S(FALSE);


!?FU(gem_GetModList);
!#VA(modListArrayID:x) (modsAmount:x) (modListGlobalVar:x); 
  !!FU:A?(numArgs:y);

  *!if&(numArgs)<2;
    *!SN:F^ShowErmError^/^Substr: invalid arguments number. Expected at least {2} arguments^;
    *!FU:E;
  *!en;


  !!SN:L^vfs.dll^/?(dll:y) A(dll)/^GetMappingsReportA^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL);
  !!SN:Bv1/v1/?s^gem_modList^;
  !!VR(savedV1:y):Sv1;
  !!SN:A(dll)/^MemFree^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL)/(savedV1);
  !!SN:Ks^gem_modList^/?(textLength:y);

  !!VR(garbageLength:y):S(NULL);
  !!VR(endOfGarbage:y):S(NULL);
  !!VR(skipNextText:y):S(FALSE);
  !!FU(NewIntArray):P?(modNamesEndings:y);
  !!VRs^gem_modListCut^:S^^;

  !!re i/0/(textLength)/1/-1;

    !!SN:Ks^gem_modList^/i/?(textSymbol:z);

    !!if&(textSymbol)=^$^;
      !!VRi:+10;
      !!VRk:Si+1;
      !!VR(modStart:y):Sk;
      !!co;
    !!en;

    !!if&(textSymbol)=^[^;
      !!if&(garbageLength);
        !!VRi:+(garbageLength);
        !!co;
      !!el;
        !!VR(startOfTextGarbage:y):Si;
        !!VR(skipNextText):S(TRUE);
      !!en;
    !!en;

    !!if&(textSymbol)=^]^;
        !!VR(garbageLength):Si -(startOfTextGarbage);
        !!VR(skipNextText):S(FALSE);
        !!co;
    !!en;

    !!VRs^gem_modListCut^&(skipNextText)=(FALSE):+^%(textSymbol)^;
  !!en;

  !!SN:Ks^gem_modListCut^/?(textLength:y);

  !!FU(NewStrArray):P?(modListArrayID);

  !!re i/0/(textLength)/1/-1;
    !!SN:Ks^gem_modListCut^/i/?(textSymbol);

    !!if&(textSymbol)=^\^;
      !!VR(modsAmount):+1;
      !!co;
    !!en;

    !!VRs^gem_mod_no_%(modsAmount)^:+(textSymbol);
  !!en;

  !!VRs^gem_modList^:S^^;
  !!VRs^gem_modListCut^:S^^;

  !!re i/1/(modsAmount);
    !!VRs^gem_mod_no_%i^:M6/?(latSymbol:y);
    !!VR(latSymbol):+1;
    !!VRs^gem_mod_no_%i^:M1/s^gem_mod_no_%i^/0/(latSymbol);
    !!FU(Array_Push):P(modListArrayID)/s^gem_mod_no_%i^;

    !!if&(numArgs)>2;                                   [if user asked mod list]
      !!VRs^gem_modListCut^:+^%s(gem_mod_no_%i)
^;                                             [add mod to the list on the next line]
    !!en;

    !!VRs^gem_mod_no_%i^:S^^;                           [remove global var]
  !!en;

  !!SN:F^ExtendArrayLifetime^/(modListArrayID);         [return id of array with mod list]

  !!if&(numArgs)>2;                                     [if user asked mod list]

    !!VRs^gem_modListCut^:M6/?(latSymbol);

    !!VR(latSymbol):+1;
    !!VRs^gem_modListCut^:M1/s^gem_modListCut^/0/(latSymbol);
    !!VR(modListGlobalVar):Z^{~text align=left}%s(gem_modListCut)}^;
  !!en;

!?FU(gem_ExtractIntsFromText);                        [returns only integer numbers as int array elements from string]
  !#VA(strPtr:x);                       [Original string.]
  !#VA(numbersArrayID:x);               [returns local array id via ?(intVar:y)]
  !#VA(amountOfNumbers:x);              [returns local array size ]

  !!VRs^gem_originalString^:S^%z(strPtr)^;
  !!SN:Ks^gem_originalString^/?(strLength:y);

  !!VR(amountOfNumberArrays:y):S1;
  !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
  !!VR(breakPoint:y):S(NULL);
  !!VR(isNeedBreakPoint:y):S(FALSE);
  !!re i/0/(strLength)/1/-1;
    !!SN:Ks^gem_originalString^/i/?(checkSymbol:z);

    !!VR(isNeedBreakPoint):S(TRUE);

    !!re (commonInt:y)/0/9;
      !!if&(checkSymbol)=^%(commonInt)^;
        !!FU(Array_Push):Pi^current_%(amountOfNumberArrays)_array_ID^/(commonInt);
        !!VR(isNeedBreakPoint):S(FALSE);
        !!br;
      !!en;
    !!en;

    !!if&(isNeedBreakPoint);
      !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
      !!co&(arrayLength)=(NULL);
      !!VR(amountOfNumberArrays):+1;
      !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
    !!en;

  !!en;


  !!VRs^gem_originalString^:S^^;
  !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
  !!VR(amountOfNumberArrays)&(arrayLength)=(NULL):-1;

  !!if&(amountOfNumberArrays);  
    !!FU(NewIntArray):P?(numbersArrayID:x);

    !!re i/1/(amountOfNumberArrays);

      !!VR(elemSumm:y):S(NULL);
      !!SN:Mi^current_%i_array_ID^/?(arrayLength:y);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:Mi^current_%i_array_ID^/j/?(elemValue:y);
        !!VR(multipler:y):S(arrayLength) -j -1;

        !!if&(multipler);
          !!re k/1/(multipler);
            !!VR(elemValue):*10;
          !!en;
        !!en;

        !!VR(elemSumm):+(elemValue);
      !!en;

      !!FU(Array_Push)&(arrayLength):P(numbersArrayID)/(elemSumm);
      !!VRi^current_%i_array_ID^:S(NULL);
    !!en;

    !!FU:A?(numArgs:y);

    !!if&(numArgs)>3;
      !!VR(totalInt:x):S(NULL);
      !!VR(fullText:z):S^^;
      !!SN:M(numbersArrayID)/?(arrayLength);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:M(numbersArrayID)/j/?(elemValue:y);
        !!SN:K^%(elemValue)^/?(intLength:y);

        !!re l/0/(intLength)/1/-1;
          !!SN:K^%(elemValue)^/l/?(textSymbol:z);
          !!VR(fullText):+(textSymbol);
        !!en;

      !!en;

    !!en;

    !!VR(amountOfNumbers):S(amountOfNumberArrays);
    !!SN:F^ExtendArrayLifetime^/(numbersArrayID);
  !!el;
    !!IF:M^There are no numbers in the text you entered^;
  !!en;




+16 | id
+22 | state;
+24 | xPos;
+26 | yPos;
+28 | width;
+30 | height;
+32 | text ptr in status_bar;
+36 | text ptr on text by RMB;
+48 | def structure ptr;
+52 | def frame number;
+56 | def frame number when pressed (if button);
+60 | mirror: 0-no, 1-yes;
+68 | Does the dialog close: 0-no, 1-yes; - only set
^;
*!en;

!?FU(gem_DlgDefProc);
!#VA(itemId:x) (currentFrame:x) (whenPressedFrame:x) (whenDisabledFrame:x) (closeDlg:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

  !!SN:E6288816/2/(currentDlgStruct)/(itemId);

  !!if&v1<1;
  *!IF:L^%^;
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:S(@currentFrame)/?(cFSyntax:y) S(@whenPressedFrame)/?(wPFSyntax:y) S(@whenDisabledFrame)/?(wDFSyntax:y) S(@closeDlg)/?(closeDlgSyntax:y);

  !!VR(itemAction:y):S(itemStructure) +52;
    !!UN&(cFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(currentFrame);
    !!UN&(cFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(currentFrame);
    
    !!if&(cFSyntax)=(ARG_SYNTAX_ADD);
      !!VR(addNumber:y):S(currentFrame);
      !!UN:C(itemAction)/4/?(currentFrame);
      !!VR(currentFrame):+(addNumber);
      !!UN:C(itemAction)/4/(currentFrame);
    !!en;


  !!VR(itemAction:y):S(itemStructure) +56;
    !!UN&(wPFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenPressedFrame);
    !!UN&(wPFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenPressedFrame);

  !!VR(itemAction:y):S(itemStructure) +60;
    !!UN&(wDFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenDisabledFrame);
    !!UN&(wDFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenDisabledFrame);

  !!VR(itemAction:y):S(itemStructure) +68;
    !!UN&(closeDlgSyntax)=(ARG_SYNTAX_GET):C(itemAction)/2/?(closeDlg);
    !!UN&(closeDlgSyntax)=(ARG_SYNTAX_SET):C(itemAction)/2/(closeDlg);  

  !!VRv1:S(savedV1);

!?FU(gem_DlgDisableBtn);
!#VA(itemId:x) (enable:x) (whenDisabledFrame:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

   !!SN:E6288816/2/(currentDlgStruct)/(itemId);
   !!if&v1<1;
   
     !!FU:E;
   !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:A?(numArgs:y);
  !!if&(numArgs)>2;
    !!VR(itemAction:y):S(itemStructure) +60;
    !!UN:C(itemAction)/4/(whenDisabledFrame);
  !!en;

  !!SN:E6287104/2/(itemStructure)/(enable);
  !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);

!?FU(gem_DlgShowItem);
!#VA(itemId:x) (showItem:x) (clickableItem:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;


  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

  !!SN:E6288816/2/(currentDlgStruct)/(itemId);

  !!if&v1<1;
  
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; 

  !!if&(showItem);

    !!SN:E6286720/2/(itemStructure)/5/6;
  !!el;

    *!FU:S(@clickableItem)/?(clickableItemSyntax:y);

    *!if&(clickableItemSyntax)=(ARG_SYNTAX_SET);
      !!if&(clickableItem);
        !!SN:E6286720/2/(itemStructure)/6/4;
      !!el;
        !!SN:E6286720/2/(itemStructure)/6/6;
      !!en;
    *!en;


  !!en;
*!IF:L^%(itemId)^;
  !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);

!?FU(gem_DlgItemSize);
!#VA(itemId:x) (width:x) (height:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;
  !!SN:E6288816/2/(currentDlgStruct)/(itemId);
    !!if&v1<1;
    *!IF:M^itemId is incorrect!^;
    !!VR(width):S0;
    !!VR(height):S0;
    !!VRv1:S(savedV1);
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:S(@width)/?(widthSyntax:y) S(@height)/?(heightSyntax:y) A?(argc:y);

  !!VR(itemAction:y):S(itemStructure) +28;

    !!if&(widthSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(width);
    !!el&(widthSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(width);
    !!el;
      !!UN:C(itemAction)/2/?(currWidth:y);
      !!VR(width):+(currWidth);

      !!if&(width)>0;
        !!UN:C(itemAction)/2/(width);
      !!el;
        !!UN:C(itemAction)/2/0;
      !!en;

    !!en;

  !!if&(argc)>(@width);
  
    !!VR(itemAction:y):S(itemStructure) +30;
    
    !!if&(heightSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(height);
    !!el&(heightSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(height);
    !!el;
      !!UN:C(itemAction)/2/?(currHeight:y);
      !!VR(height):+(currHeight);
      !!UN:C(itemAction)/2/(height);

      !!if&(height)>0;
        !!UN:C(itemAction)/2/(height);
      !!el;
        !!UN:C(itemAction)/2/0;
      !!en;
    !!en;


    !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!en;


  !!VRv1:S(savedV1);


!?FU(gem_DlgItemPosition);
!#VA(itemId:x) (xPos:x) (yPos:x) (redraw:x) (customDlgStruct:x) (parrent:x);
  !!FU:A?(argNum:y);
  !!if|(itemId)<0/(argNum)<=(@itemId);
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  ; parameters of any dialog element
  ; text, pictures, buttons, etc.
  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(dlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(dlgStruct:y);
  !!en;
  !!SN:E6288816/2/(dlgStruct)/(itemId);
  !!if&v1<1;
    !!VRv1:S(savedV1);
    *!IF:M^itemId is incorrect!^;
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!VR(parrent):S(itemStructure) +4;
  !!UN:C(parrent)/4/?(parrent);
  !!FU:S(@xPos)/?(xSyntax:y);

  !!VR(itemAction:y):S(itemStructure) +24;
    !!if&(xSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(xPos);
    !!el&(xSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(xPos);
    !!el;
      !!UN:C(itemAction)/2/?(currX:y);
      !!VR(xPos):+(currX);
      !!UN:C(itemAction)/2/(xPos);
    !!en;

  !!FU&(argNum)<(@yPos):E;
  !!FU:S(@yPos)/?(ySyntax:y);

  !!VR(itemAction:y):S(itemStructure) +26;
    !!if&(ySyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(yPos);
    !!el&(ySyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(yPos);
    !!el;
      !!UN:C(itemAction)/2/?(currY:y);
      !!VR(yPos):+(currY);
      !!UN:C(itemAction)/2/(yPos);    
    !!en;

  !!SN&(redraw):E6288864/2/(dlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);
!?FU(gem_GetItemByStructure);
!#VA(itemStructure:x) (itemId:x);

*!UN:C(itemAction)/2/?(y);

!?FU(gem_GetItemStructure);
!#VA(itemId:x) (itStructure:x);
  !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!SN:E6288816/2/(currentDlgStruct)/(itemId);
  !!VR(itStructure)&v1>0:Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

!?FU(gem_DlgReload);
!#VA(dlgFileName:x);
  !!VRz1:S^%z(dlgFileName)^;
  !!SN:E5620400/3/z1;
  !!VRv2:Sv1+24;
  !!UN:Cv2/4/1;
  !!SN:E5624576/3/v1;
  *!IF:L^done!^;


!?FU(ChangeDwellingName);
!#VA(objSubtype:x) (name:x);
!!UN:C6886304/(UNC_INT)/?(txtPtr:y) C(txtPtr)/32/(UNC_INT)/?(txtPtr);
!!VR(objSubtype): *(UNC_INT)+(txtPtr);
!!UN:C(objSubtype)/(UNC_INT)/?(addr:y);

!!FU:S(@name)/?(nameSyntax:y);
!!if&(nameSyntax)=(ARG_SYNTAX_GET);
  !!SN:B(addr)/d/?(str:z);
  !!VR(name):Z(str);
!!el&(nameSyntax)=(ARG_SYNTAX_SET);
  !!SN:B(addr)/d/^%z(name)^;
!!el;
  !!SN:B(addr)/d/?(str:z);
  !!VR(str):+^%z(name)^;
  !!SN:B(addr)/d/(str);
!!en;

!?FU(gem_GetAdvDwellingName);
!#VA(objType:x) (objSubtype:x) (objName:x);
  !!FU:A?(numArgs:y) S(@objName)/(nameSyntax:y);

  !!if|(numArgs)<(@objName)/(nameSyntax)<>(ARG_SYNTAX_GET);
    !!IF:M^incorrect Arguments number or type!
    use only {GET} Syntax for getting dwelling name^;
    !!FU:E;
  !!en;

  !!if&(objType)<>(OBJ_CREATURE_GENERATOR_1)/(objType)<>(OBJ_CREATURE_GENERATOR_4);
    !!IF:M^incorrect object Type number!
    use only Types %(OBJ_CREATURE_GENERATOR_1) or %(OBJ_CREATURE_GENERATOR_4) object Types^;
    !!FU:E;
  !!en;

  !!UN&(objType)=(OBJ_CREATURE_GENERATOR_1):C6886304/4/?y1;            [crGen1.txt adress]
  !!UN&(objType)=(OBJ_CREATURE_GENERATOR_4):C6887052/4/?y1;            [crGen4.txt adress]

; @Master Of Puppets

  !!VRy1:+32;
  !!UN:Cy1/4/?y2;
  !!VR(objSubtype):*4+y2;
  !!UN:C(objSubtype)/4/?y1;
  !!SN:X?y4 Xy1 X?z1 Xy4;
  !!VR(objName):Z^%z1^;


006A6C5C [PriSkill.txt adress]
006A7584 PlColors.txt adress
006A75D8 
Garrison.txt
006A5438 MineName.txt
006A53F8 prim
006A5390 RESTYPES.TXT
004E6D87 SSTRAITS.TXT
; @Master Of Puppets

004E6BCB
006A60AC ARRAYTXT.TXT
!?FU(gem_GetTxtFileString);
!#VA(txtFileName:x) (stringNum:x) (string:x); 
  !!VR(txtLoadAddres:y):S0;Dwelling.txt

  !!FU(StrToLower):Pz(txtFileName)/?(txtName:z);(txtName:z);

  !!if|(txtName)=^objnames.txt^/(txtName)=^objnames^;
    !!VR(txtLoadAddres):+6974640;obj

  !!el|(txtName)=^arraytxt.txt^/(txtName)=^arraytxt^;
    !!VR(txtLoadAddres):+6971564;arraytxt

  !!el|(txtName)=^minename.txt^/(txtName)=^minename^;
    !!VR(txtLoadAddres):+6968376;mine

  !!el|(txtName)=^priskill.txt^/(txtName)=^priskill^;
    !!VR(txtLoadAddres):+6974556;ps

  !!el|(txtName)=^restypes.txt^/(txtName)=^restypes^;
    !!VR(txtLoadAddres):+6968208;rest

  !!el|(txtName)=^plcolors.txt^/(txtName)=^plcolors^;
    !!VR(txtLoadAddres):+6976900;plcol

  !!el|(txtName)=^dwelling.txt^/(txtName)=^dwelling^;
    !!VR(txtLoadAddres):+6972144;dwell

  !!el|(txtName)=^crgen1.txt^/(txtName)=^crgen1^;
    !!VR(txtLoadAddres):+6886304;[crGen1.txt adress]

  !!el|(txtName)=^crgen4.txt^/(txtName)=^crgen4^;
    !!VR(txtLoadAddres):+6887052;[crGen4.txt adress]

  *!el|(txtName)=^help.txt^/(txtName)=^help^;
    *!VR(txtLoadAddres):+6976896;[help.txt adress]

  !!el;
    !!VR(string):Z^Wrong txt file name!^;
    !!FU:E;
  !!en;

; @Master Of Puppets


  !!UN:C(txtLoadAddres)/4/?y1;            
  !!VRy1:+32;
  !!UN:Cy1/4/?y2;
  !!VR(stringNum):*4+y2;
  !!UN:C(stringNum)/4/?y1;
  !!SN:X?y4 Xy1 X?z1 Xy4;
  *!IF:L^%(stringNum) %y1^;
  *!VR(string):Z^%z1^;
!?FU(OnKeyPressed)&x1=(KEY_6);
*!VRy1:S6976896;

*!VRy1:S6887052;
44
*!UN:Cy1/4/?y2 Cy2/32/4/?y3;

*!UN:Cy3/1548/4/?y1 Cy1/36/4/?y1;
*!SN:By1/d/?z1;
*!IF:L^%z1 %y2^;



!?FU(gem_GetTxtTableString);
!#VA(txtLoadAddres:x) (rowNum:x) (colNum:x) (string:x);

!!VR(savedV1:y):Sv1;
!!SN:E7827723/(CALLCONV_CDECL)/(rowNum)/(colNum)/(txtLoadAddres);
!!SN:Bv1/d/?(text:z);
!!VR(string):Z(text);
!!VRv1:S(savedV1);

!!FU:E;

!!if|(rowNum)<1/(colNum)<1;
  !!IF:M^minimal row/col index is "1"^;
!!en;
!!UN:C(txtLoadAddres)/4/?(txtTablePtr:y) C(txtTablePtr:y)/32/4/?(vTablePtr:y);

!!VR(rowNum):*(UNC_INT);
!!VR(colNum):*(UNC_INT) +28;

!!UN:C(vTablePtr)/(rowNum)/(UNC_INT)/?(rowPtr:y) C(rowPtr)/(colNum)/(UNC_INT)/?(cellPtr:y);
!!SN:B(cellPtr)/d/?(text:z);
!!VR(string):Z(text);



!?FU(gem_DlgSetColor);
  !#VA(dlgStruct:x) (setColor:x);
  !!SN:E7510739/1/(dlgStruct);
  !!UN:Cv1/4/?y1;
  !!VRy2:Sy1 +76;
  !!UN:Cy2/4/?y3;
  !!SN:E6288384/2/y1/512/13/y3/(setColor);


!?FU(gem_Town_GetStruct);
; x1 - town number on map (0...47)
;?x2 - return: itemId structure town
!#VA(townId:x) (buildId:x); 
  !!IF&(townId)<(MAP_TOWN_FIRST)|(townId)>(MAP_TOWN_LAST):M^{FU(gem_Town_GetStruct)}: Wrong town id.^;
  !!UN:C(GAME_MANAGER)/(UNC_UINT32)/?(game:y); 
  !!UN:C(game)/136724/(UNC_UINT32)/?(itemId:y); 
  !!VR(buildId):S(townId) *360 +(itemId);
  !!IF&(buildId)<43200000:M^{FU(gem_Town_GetStruct): Attention!}
  Error in getting town structure address. 
  The game may fall at any time.^; 

!?FU(Town_IsSpellBanned); @igrik - so much thanks
!#VA(townId:x) (spellID:x) (result:x);
  !!VR(result):S(FALSE);

  ; получаем структуру города
  !!FU(gem_Town_GetStruct):P(townId)/?(town:y);

  ; работаем с битами запрета заклинаний в городе
  ; bit = (1 << (id & 31) & *(spellsBits + (id >> 5)) )
  !!VR(bitOffset:y):S(spellID) :32 *4 +212;  212=смещение до забаненых спеллов (town->0xD4: int[4])
  !!UN:C(town)/(bitOffset)/4/?(spellsBits:y);
  !!VR(leftPart:y):S(spellID) &31;

  !!VR(isSpellBannedInTown:y):S1 Sd<<(leftPart) &(spellsBits);
  *!IF&(SPELL_PROTECTION_FROM_FIRE)=(spellID):M^%(leftPart)  %(spellsBits)^;

  ; проверяем на запрет искомое заклинание в городе
  !!if&(isSpellBannedInTown)<>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;

  ; работаем с битами запрета заклинаний в игре
  !!UN:C6919480/4/?(gameMgr:y); 
  !!VR(spellBannedOfsset:y):S74 +(spellID);
  !!UN:C(gameMgr)/(spellBannedOfsset)/1/?(isSpellBannedInGame:y);

  ; проверяем на запрет искомое заклинание в игре
  !!if&(isSpellBannedInGame)>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;


  !?FU(Town_CanBuildingBuilt);
  ; x1 - town number on map (0...47)
  ; x2 - building id
  ; x3 - return: bool (0-no, 1-yes)
  !!FU(gem_Town_GetStruct):Px1/?y1;
  !!CA0/x1:R?y2 R0;
  !!SN:E6033696/2/y1/x2;
  !!VRx3:S0;    
  !!VRx3&v1<>0:S1;
  !!CA0/x1:Ry2;