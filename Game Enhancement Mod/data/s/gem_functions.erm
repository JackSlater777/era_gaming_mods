ZVSE2
; gem_functions.erm
; version 2.00
; author: daemon_n.





!?FU(gem_GetRandomMon);
  !#VA(mon:x) (monsToExcl:x) (mons[10]:x);

  !!FU(GetMaxMonsterId):P?(result:y);
  !!VR(mon):R0/0/(result);

  !!VR(flag:y):S(TRUE);
  !!VR(flag)|(mon)=(MON_NOT_USED_1)/(mon)=(MON_NOT_USED_2)/(mon)=(MON_NOT_USED_3)/(mon)=(MON_NOT_USED_4):S(FALSE); [not used]
  !!VR(flag)&(mon)>=(MON_EMISSARY_OF_WAR)/(mon)<=(MON_EMISSARY_OF_LORE):S(FALSE); [Emissaries]
  !!VR(flag)&(mon)>=(MON_PALADIN_A)/(mon)<=(MON_ASTRAL_SPIRIT_D):S(FALSE); [Commanders]
  !!VR(flag)&(mon)>=(MON_CATAPULT)/(mon)<=(MON_ARROW_TOWERS):S(FALSE); [war_machines]
  
  !!if&(monsToExcl);
    !!re i/0/(monsToExcl)/1/-1;
      !!VR(flag)&(mon)=(mons[i]):S(FALSE); [ultra dragons]
    !!en;
  !!en;

  !!FU(gem_GetRandomMon)&(flag)=(FALSE):P?(mon)/(monsToExcl)/(mons[0])/(mons[1])/(mons[2])/(mons[3])/(mons[4])/(mons[5])/(mons[6])/(mons[7])/(mons[9]);


!?FU(gem_GetPlayerActiveHeroesList);
!#VA(playerID:x) (array:x);
  !!VR(array):S0;

  !#VA(hero[8]:y);
  !!OW:O(playerID)/?(heroesOnMap:y)/?(hero[0])/?(hero[1])/?(hero[2])/?(hero[3])/?(hero[4])/?(hero[5])/?(hero[6])/?(hero[7]);
  !!if&(heroesOnMap);
    !!FU(NewIntArray):P(heroesOnMap)/?(array);

    !!re i/0/(heroesOnMap)/1/-1;
      !!SN:M(array)/i/(hero[i]);
    !!en;
    !!SN:F^ExtendArrayLifetime^/(array);
  !!en;

!?FU(gem_GetPlayerHeroesList);
!#VA(playerID:x) (array:x);
  !!VR(array):S-1;

  !!OW:H(playerID)/1;
  !!if&v1;
    !!FU(NewIntArray):Pv1/?(array);

    !!re i/2/v1/1/1;
      !!SN:M(array)/i/vi;
    !!en;

    !!SN:F^ExtendArrayLifetime^/(array);
  !!en;



!?FU(gem_UpdateScoutingRange);
!#VA(heroId:x) (arrayId:x);
  !!VR(savedV1:y):Sv1;
  !!UN:C(GAME_MANAGER)/4/?(gameMgr:y);
  !!FU:A?(argNum:y);

  !!if&(argNum)>1;
    !!SN:M(arrayId)/?(size:y);
    !!re i/0/(size)/1/-1;
      !!SN:V(arrayId)/i/?(heroId);
      !!HE(heroId):Z?(hero:y) P?(x:y)/?(y:y)/?(z:y) O?(owner:y);

      !!SN:E5128928/(CALLCONV_THISCALL)/(hero);                                   [int __thiscall GetScootingRadius(_Hero_ *this) 4E42E0]
      !!SN:E4836816/(CALLCONV_THISCALL)/(gameMgr)/(x)/(y)/(z)/(owner)/v1; [char __thiscall OpenArea(_GameMgr_ *this, int x, int y, int z, int player, int radius, int a7); 49CDD0]
    !!en;
  !!el;
    !!HE(heroId):Z?(hero:y) P?(x:y)/?(y:y)/?(z:y) O?(owner:y);
    !!SN:E5128928/(CALLCONV_THISCALL)/(hero);                                   [int __thiscall GetScootingRadius(_Hero_ *this) 4E42E0]
    !!SN:E4836816/(CALLCONV_THISCALL)/(gameMgr)/(x)/(y)/(z)/(owner)/v1; [char __thiscall OpenArea(_GameMgr_ *this, int x, int y, int z, int player, int radius, int a7); 49CDD0]
  !!en;

  !!VRv1:S(savedV1);

!?FU(gem_AdvMgr_HideHero);
  !#VA(hero[3]:x);
  !!FU:A?(numArgs:y);
  !!if&(numArgs)>1;
    !!HE(hero[0])/(hero[1])/(hero[2]):Z?(badHero:y);
  !!el;
    !!HE(hero[0]):Z?(badHero:y);
  !!en;
  !!SN:E5077328/(CALLCONV_THISCALL)/(badHero);         [hide hero if it is there]

!?FU(gem_AdvMgr_ShowHero);
  !#VA(hero[3]:x);
  !!FU:A?(numArgs:y);
  !!if&(numArgs)>1;
    !!HE(hero[0])/(hero[1])/(hero[2]):Z?(heroPtr:y) N?(heroId:y);
  !!el;
    !!HE(hero[0]):Z?(heroPtr:y) N?(heroId:y);
  !!en;
  !!SN:E5077056/(CALLCONV_THISCALL)/(heroPtr)/(OBJ_HERO)/(heroId:y);         [hide hero if it is there]




************************************************************************
************************************************************************
*********************** T E X T   H A N D L I N G **********************
************************************************************************
************************************************************************


!?FU(gem_ExtractIntsFromText);                        [returns only integer numbers as int array elements from string]
  !#VA(strPtr:x);                       [Original string.]
  !#VA(numbersArrayID:x);               [returns local array id via ?(intVar:y)]
  !#VA(amountOfNumbers:x);              [returns local array size ]

  !!VRs^gem_originalString^:S^%z(strPtr)^;
  !!SN:Ks^gem_originalString^/?(strLength:y);

  !!VR(amountOfNumberArrays:y):S1;
  !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
  !!VR(breakPoint:y):S(NULL);
  !!VR(isNeedBreakPoint:y):S(FALSE);
  !!re i/0/(strLength)/1/-1;
    !!SN:Ks^gem_originalString^/i/?(checkSymbol:z);

    !!VR(isNeedBreakPoint):S(TRUE);

    !!re (commonInt:y)/0/9;
      !!if&(checkSymbol)=^%(commonInt)^;
        !!FU(Array_Push):Pi^current_%(amountOfNumberArrays)_array_ID^/(commonInt);
        !!VR(isNeedBreakPoint):S(FALSE);
        !!br;
      !!en;
    !!en;

    !!if&(isNeedBreakPoint);
      !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
      !!co&(arrayLength)=(NULL);
      !!VR(amountOfNumberArrays):+1;
      !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
    !!en;

  !!en;


  !!VRs^gem_originalString^:S^^;
  !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
  !!VR(amountOfNumberArrays)&(arrayLength)=(NULL):-1;

  !!if&(amountOfNumberArrays);  
    !!FU(NewIntArray):P?(numbersArrayID:x);

    !!re i/1/(amountOfNumberArrays);

      !!VR(elemSumm:y):S(NULL);
      !!SN:Mi^current_%i_array_ID^/?(arrayLength:y);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:Mi^current_%i_array_ID^/j/?(elemValue:y);
        !!VR(multipler:y):S(arrayLength) -j -1;

        !!if&(multipler);
          !!re k/1/(multipler);
            !!VR(elemValue):*10;
          !!en;
        !!en;

        !!VR(elemSumm):+(elemValue);
      !!en;

      !!FU(Array_Push)&(arrayLength):P(numbersArrayID)/(elemSumm);
      !!VRi^current_%i_array_ID^:S(NULL);
    !!en;

    !!FU:A?(numArgs:y);

    !!if&(numArgs)>3;
      !!VR(totalInt:x):S(NULL);
      !!VR(fullText:z):S^^;
      !!SN:M(numbersArrayID)/?(arrayLength);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:M(numbersArrayID)/j/?(elemValue:y);
        !!SN:K^%(elemValue)^/?(intLength:y);

        !!re l/0/(intLength)/1/-1;
          !!SN:K^%(elemValue)^/l/?(textSymbol:z);
          !!VR(fullText):+(textSymbol);
        !!en;

      !!en;

    !!en;

    !!VR(amountOfNumbers):S(amountOfNumberArrays);
    !!SN:F^ExtendArrayLifetime^/(numbersArrayID);
  !!el;
    !!IF:M^There are no numbers in the text you entered^;
  !!en;

!?FU(gem_GetModList);
!#VA(modListArrayID:x) (modsAmount:x) (modListGlobalVar:x); 
  !!FU:A?(numArgs:y);

  *!if&(numArgs)<2;
    *!SN:F^ShowErmError^/^Substr: invalid arguments number. Expected at least {2} arguments^;
    *!FU:E;
  *!en;


  !!SN:L^vfs.dll^/?(dll:y) A(dll)/^GetMappingsReportA^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL);
  !!SN:Bv1/v1/?s^gem_modList^;
  !!VR(savedV1:y):Sv1;
  !!SN:A(dll)/^MemFree^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL)/(savedV1);
  !!SN:Ks^gem_modList^/?(textLength:y);

  !!VR(garbageLength:y):S(NULL);
  !!VR(endOfGarbage:y):S(NULL);
  !!VR(skipNextText:y):S(FALSE);
  !!FU(NewIntArray):P?(modNamesEndings:y);
  !!VRs^gem_modListCut^:S^^;

  !!re i/0/(textLength)/1/-1;

    !!SN:Ks^gem_modList^/i/?(textSymbol:z);

    !!if&(textSymbol)=^$^;
      !!VRi:+10;
      !!VRk:Si+1;
      !!VR(modStart:y):Sk;
      !!co;
    !!en;

    !!if&(textSymbol)=^[^;
      !!if&(garbageLength);
        !!VRi:+(garbageLength);
        !!co;
      !!el;
        !!VR(startOfTextGarbage:y):Si;
        !!VR(skipNextText):S(TRUE);
      !!en;
    !!en;

    !!if&(textSymbol)=^]^;
        !!VR(garbageLength):Si -(startOfTextGarbage);
        !!VR(skipNextText):S(FALSE);
        !!co;
    !!en;

    !!VRs^gem_modListCut^&(skipNextText)=(FALSE):+^%(textSymbol)^;
  !!en;

  !!SN:Ks^gem_modListCut^/?(textLength:y);

  !!FU(NewStrArray):P?(modListArrayID);

  !!re i/0/(textLength)/1/-1;
    !!SN:Ks^gem_modListCut^/i/?(textSymbol);

    !!if&(textSymbol)=^\^;
      !!VR(modsAmount):+1;
      !!co;
    !!en;

    !!VRs^gem_mod_no_%(modsAmount)^:+(textSymbol);
  !!en;

  !!VRs^gem_modList^:S^^;
  !!VRs^gem_modListCut^:S^^;

  !!re i/1/(modsAmount);
    !!VRs^gem_mod_no_%i^:M6/?(latSymbol:y);
    !!VR(latSymbol):+1;
    !!VRs^gem_mod_no_%i^:M1/s^gem_mod_no_%i^/0/(latSymbol);
    !!FU(Array_Push):P(modListArrayID)/s^gem_mod_no_%i^;

    !!if&(numArgs)>2;                                   [if user asked mod list]
      !!VRs^gem_modListCut^:+^%s(gem_mod_no_%i)%T(gem.endl)^;                                             [add mod to the list on the next line]
    !!en;

    !!VRs^gem_mod_no_%i^:S^^;                           [remove global var]
  !!en;

  !!SN:F^ExtendArrayLifetime^/(modListArrayID);         [return id of array with mod list]

  !!if&(numArgs)>2;                                     [if user asked mod list]

    !!VRs^gem_modListCut^:M6/?(latSymbol);

    !!VR(latSymbol):+1;
    !!VRs^gem_modListCut^:M1/s^gem_modListCut^/0/(latSymbol);
    !!VR(modListGlobalVar):Z^{~text align=left}%s(gem_modListCut)}^;
  !!en;




!?FU(StringReplaceINT);
!#VA(string:x) (substr:x) (result:x);
  !!VRs^temp^:Sz(string);
  !!SN:Ks^temp^/?(length:y);

  !!re i/0/(length)/1/-1;
    !!SN:Ks^temp^/i/?(char:z);
    !!if&(char)<>^0^;
      !!VR(int:y):V(char);
      !!br&(int)>0;
    !!en;
  !!en;
  !!if&i<(length);
    !!VR(len:y):S(length) -i;
    !!VRs^_temp^:M1/s^temp^/i/(len);
    !!VR(int):Vs^_temp^;
    !!SN:K^%(int)^/?(numLen:y);
    !!VR(rPos:y):Si+(numLen);
    !!VR(rLen:y):S(length) -(rPos);
    !!VR(left:z):M1/s^temp^/0/i;
    !!VR(right:z):M1/s^temp^/(rPos)/(rLen);
    !!VR(result):Z^%(left)%z(substr)%(right)^;
  !!el;
    !!VR(result):Zz(string);
  !!en;
  !!SN:W^temp^ ^_temp^;




!?FU(gem_CheckModFolderNameExists);         [that function get mod list in array from !FU(gem_GetModList) and compare each folder with]
!#VA(modNameForCheck:x) (isExist:x);
  !!VR(emptyStr:z):S^%z(modNameForCheck)^ H1;
  !!if|-1/(emptyStr)=^^;        [show error if mod name is not string or empty]
    !!IF:M^{The mod name you are trying to check is incorrect!}^;
    !!FU:E;
  !!en;

  !!VR(textModNameForCheck:z):S^%z(modNameForCheck)^;
  !!FU(gem_GetModList):P?(modListArrayID:y)/?(modsAmount:y);

  !!FU(StrToLower):P(textModNameForCheck)/?(textModNameForCheck);

  !!re i/0/(modsAmount)/1/-1;
    !!SN:M(modListArrayID)/i/?(modName:z);
    !!FU(StrToLower):P(modName)/?(modName);

    !!if&(textModNameForCheck)=(modName);
      !!VR(isExist):S(TRUE);
      !!FU:E;    
    !!en;
  !!en;

  !!VR(isExist):S(FALSE);














************************************************************************
************************************************************************
************************ D I A L O G   I T E M S ***********************
************************************************************************
************************************************************************


+16 | id
+22 | state;
+24 | xPos;
+26 | yPos;
+28 | width;
+30 | height;
+32 | text ptr in status_bar;
+36 | text ptr on text by RMB;
+48 | def structure ptr;
+52 | def frame number;
+56 | def frame number when pressed (if button);
+60 | mirror: 0-no, 1-yes;
+68 | Does the dialog close: 0-no, 1-yes; - only set
^;
*!en;
!?FU(gem_DlgDefProc);
!#VA(itemId:x) (currentFrame:x) (whenPressedFrame:x) (whenDisabledFrame:x) (closeDlg:x) (dlgObj:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!FU:A?(numArgs:y);
  !!if&(numArgs)>=(@currentFrame);
    !!VR(savedV1:y):Sv1;
    !!if&(dlgObj)=0;
      !!FU(H3Dlg_GetCurrentDlg):P?(dlgObj);
    !!en;

    !!SN:E6288816/2/(dlgObj)/(itemId);     [Get item obj]

    !!if&v1>0;

      !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)
      *!FU:A?(numArgs:y);

      !!FU:S(@currentFrame)/?(cFSyntax:y) S(@whenPressedFrame)/?(wPFSyntax:y) S(@whenDisabledFrame)/?(wDFSyntax:y) S(@closeDlg)/?(closeDlgSyntax:y);

      !!VR(itemAction:y):S(itemStructure) +52; 

      !!if&(cFSyntax)=(ARG_SYNTAX_GET);
        !!UN:C(itemAction)/4/?(currentFrame);
        
      !!el&(cFSyntax)=(ARG_SYNTAX_SET);
        !!UN:C(itemAction)/4/(currentFrame);

      !!el;
        !!VR(addNumber:y):S(currentFrame);
        !!UN:C(itemAction)/4/?(currentFrame);
        !!VR(currentFrame):+(addNumber);
        !!UN:C(itemAction)/4/(currentFrame);
      !!en;

      !!if&(numArgs)>=(@whenPressedFrame);
        !!VR(itemAction:y):S(itemStructure) +56;
        !!UN&(wPFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenPressedFrame);
        !!UN&(wPFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenPressedFrame);
      !!en;

      !!VR(itemAction:y):S(itemStructure) +60;
        !!UN&(wDFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenDisabledFrame);
        !!UN&(wDFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenDisabledFrame);

      !!VR(itemAction:y):S(itemStructure) +68;
        !!UN&(closeDlgSyntax)=(ARG_SYNTAX_GET):C(itemAction)/2/?(closeDlg);
        !!UN&(closeDlgSyntax)=(ARG_SYNTAX_SET):C(itemAction)/2/(closeDlg);  
    !!en;
  !!en;

  !!VRv1:S(savedV1);

!?FU(gem_DlgDisableBtn);
!#VA(itemId:x) (enable:x) (whenDisabledFrame:x) (redraw:x) (dlgObj:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(dlgObj)=0;
    !!FU(H3Dlg_GetCurrentDlg):P?(dlgObj);
  !!en;

  !!SN:E6288816/2/(dlgObj)/(itemId);
  !!if&v1>0;
   !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

   !!FU:A?(numArgs:y);
   !!if&(numArgs)>2;
     !!VR(itemAction:y):S(itemStructure) +60;
     !!UN:C(itemAction)/4/(whenDisabledFrame);
   !!en;

   !!SN:E6287104/2/(itemStructure)/(enable);
   !!if&(redraw);
     !!SN&(redraw)=1:E6288864/2/(dlgObj)/1/-65535/65535; [update currentDlg;]
     !!SN&(redraw)=-1:E6288864/2/(dlgObj)/1/(itemId)/(itemId); [update onlyItem;]
   !!en;

  !!en;


  !!VRv1:S(savedV1);


!?FU(gem_DlgShowItem);
!#VA(itemId:x) (showItem:x) (clickableItem:x) (redraw:x) (currentDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;


  !!VR(savedV1:y):Sv1;

  !!if&(currentDlgStruct)=0;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct);
  !!en;

  !!SN:E6288816/2/(currentDlgStruct)/(itemId);

  !!if&v1>0;
    !!VR(itemStructure:y):Sv1; 

    !!if&(showItem);

      !!SN:E6286720/2/(itemStructure)/5/6;
    !!el;

      *!FU:S(@clickableItem)/?(clickableItemSyntax:y);

      *!if&(clickableItemSyntax)=(ARG_SYNTAX_SET);
      !!if&(clickableItem);
        !!SN:E6286720/2/(itemStructure)/6/4;
      !!el;
        !!SN:E6286720/2/(itemStructure)/6/6;
      !!en;
      *!en;
    !!en;
    !!if&(redraw);
      !!SN&(redraw)=1:E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]
      !!SN&(redraw)=-1:E6288864/2/(currentDlgStruct)/1/(itemId)/(itemId); [update onlyItem;]
    !!en;
  !!en;

  !!VRv1:S(savedV1);

!?FU(gem_DlgItemSize);
!#VA(itemId:x) (width:x) (height:x) (redraw:x) (currentDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;


  !!FU:A?(argc:y);


  !!if&(argc)>(@itemId);
    !!VR(savedV1:y):Sv1;

    !!if&(currentDlgStruct)=0;
      !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct);
    !!en;

    !!SN:E6288816/2/(currentDlgStruct)/(itemId);

    !!if&v1>0;
      !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

      !!FU:S(@width)/?(widthSyntax:y) S(@height)/?(heightSyntax:y);

      !!VR(itemAction:y):S(itemStructure) +28;

      !!if&(widthSyntax)=(ARG_SYNTAX_GET);
        !!UN:C(itemAction)/2/?(width);
      !!el&(widthSyntax)=(ARG_SYNTAX_SET);
        !!UN:C(itemAction)/2/(width);
      !!el;
        !!UN:C(itemAction)/2/?(currWidth:y);
        !!VR(width):+(currWidth);

        !!if&(width)>0;
          !!UN:C(itemAction)/2/(width);
        !!el;
          !!UN:C(itemAction)/2/0;
        !!en;
      !!en;

      !!if&(argc)>(@width);
      
        !!VR(itemAction:y):S(itemStructure) +30;
        
        !!if&(heightSyntax)=(ARG_SYNTAX_GET);
          !!UN:C(itemAction)/2/?(height);
        !!el&(heightSyntax)=(ARG_SYNTAX_SET);
          !!UN:C(itemAction)/2/(height);
        !!el;
          !!UN:C(itemAction)/2/?(currHeight:y);
          !!VR(height):+(currHeight);
          !!UN:C(itemAction)/2/(height);

          !!if&(height)>0;
            !!UN:C(itemAction)/2/(height);
          !!el;
            !!UN:C(itemAction)/2/0;
          !!en;
        !!en;

      !!if&(redraw);
        !!SN&(redraw)=1:E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]
        !!SN&(redraw)=-1:E6288864/2/(currentDlgStruct)/1/(itemId)/(itemId); [update onlyItem;]
      !!en;

      !!en;
    
    !!en;

    !!VRv1:S(savedV1);
    
  !!en;




!?FU(gem_DlgItemPosition);
!#VA(itemId:x) (xPos:x) (yPos:x) (redraw:x) (customDlgStruct:x) (parrent:x);
  !!FU:A?(argNum:y);
  !!if|(itemId)<0/(argNum)<=(@itemId);
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  ; parameters of any dialog element
  ; text, pictures, buttons, etc.
  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(dlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(dlgStruct:y);
  !!en;
  !!SN:E6288816/2/(dlgStruct)/(itemId);
  !!if&v1<1;
    !!VR(xPos):S-1;
    !!VR(yPos):S-1;

    !!VRv1:S(savedV1);
    *!IF:M^itemId is incorrect!^;
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!VR(parrent):S(itemStructure) +4;
  !!UN:C(parrent)/4/?(parrent);
  !!FU:S(@xPos)/?(xSyntax:y);

  !!VR(itemAction:y):S(itemStructure) +24;
    !!if&(xSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(xPos);
    !!el&(xSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(xPos);
    !!el;
      !!UN:C(itemAction)/2/?(currX:y);
      !!VR(xPos):+(currX);
      !!UN:C(itemAction)/2/(xPos);
    !!en;

  !!FU&(argNum)<(@yPos):E;
  !!FU:S(@yPos)/?(ySyntax:y);

  !!VR(itemAction:y):S(itemStructure) +26;
    !!if&(ySyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(yPos);
    !!el&(ySyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(yPos);
    !!el;
      !!UN:C(itemAction)/2/?(currY:y);
      !!VR(yPos):+(currY);
      !!UN:C(itemAction)/2/(yPos);    
    !!en;
    !!if&(redraw);
      !!SN&(redraw)=1:E6288864/2/(dlgStruct)/1/-65535/65535; [update currentDlg;]
      !!SN&(redraw)=-1:E6288864/2/(dlgStruct)/1/(itemId)/(itemId); [update onlyItem;]
    !!en;

  !!VRv1:S(savedV1);

!?FU(gem_GetItemStructure);
!#VA(itemId:x) (itStructure:x);
  !!VR(savedV1:y):Sv1;

  !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!SN:E6288816/2/(currentDlgStruct)/(itemId);
  !!VR(itStructure)&v1>0:Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!VRv1:S(savedV1);



!?FU(gem_DlgReload);
!#VA(dlgFileName:x);
  !!VRz1:S^%z(dlgFileName)^;
  !!FU(FileExists):Pz1/?y1;
  *!IF:L^%y1^;
*!if&y1;
  !!SN:E5620400/3/z1;
  !!VRv2:Sv1+24;
  !!UN:Cv2/4/1;
  !!SN:E5624576/3/v1;
*!en;

  *!IF:L^done!^;

!?FU(gem_DlgSetColor);
!#VA(dlgId:x) (setColor:x);
  !!SN:E7510739/1/(dlgId);
  !!UN:Cv1/4/?(dlgObj:y);
  *!VRy2:Sy1 +76;
  !!UN:C(dlgObj)/76/4/?(backGroundId:y);
  !!SN:E6288384/2/(dlgObj)/512/13/(backGroundId)/(setColor);
4C
!?FU(ChangeDwellingName);
!#VA(objSubtype:x) (name:x);
!!UN:C6886304/(UNC_INT)/?(txtPtr:y) C(txtPtr)/32/(UNC_INT)/?(txtPtr);
!!VR(objSubtype): *(UNC_INT)+(txtPtr);
!!UN:C(objSubtype)/(UNC_INT)/?(addr:y);

!!FU:S(@name)/?(nameSyntax:y);
!!if&(nameSyntax)=(ARG_SYNTAX_GET);
  !!SN:B(addr)/d/?(str:z);
  !!VR(name):Z(str);
!!el&(nameSyntax)=(ARG_SYNTAX_SET);
  !!SN:B(addr)/d/^%z(name)^;
!!el;
  !!SN:B(addr)/d/?(str:z);
  !!VR(str):+^%z(name)^;
  !!SN:B(addr)/d/(str);
!!en;




!?FU(gem_Town_GetStruct);
; x1 - town number on map (0...47)
;?x2 - return: itemId structure town
!#VA(townId:x) (buildId:x); 
  !!IF&(townId)<(MAP_TOWN_FIRST)|(townId)>(MAP_TOWN_LAST):M^{FU(gem_Town_GetStruct)}: Wrong town id.^;
  !!UN:C(GAME_MANAGER)/(UNC_UINT32)/?(game:y); 
  !!UN:C(game)/136724/(UNC_UINT32)/?(itemId:y); 
  !!VR(buildId):S(townId) *360 +(itemId);
  !!IF&(buildId)<43200000:M^{FU(gem_Town_GetStruct): Attention!}
  Error in getting town structure address. 
  The game may fall at any time.^; 

!?FU(Town_IsSpellBanned); @igrik - so much thanks
!#VA(townId:x) (spellID:x) (result:x);
  !!VR(result):S(FALSE);

  ; получаем структуру города
  !!FU(gem_Town_GetStruct):P(townId)/?(town:y);

  ; работаем с битами запрета заклинаний в городе
  ; bit = (1 << (id & 31) & *(spellsBits + (id >> 5)) )
  !!VR(bitOffset:y):S(spellID) :32 *4 +212;  212=смещение до забаненых спеллов (town->0xD4: int[4])
  !!UN:C(town)/(bitOffset)/4/?(spellsBits:y);
  !!VR(leftPart:y):S(spellID) &31;

  !!VR(isSpellBannedInTown:y):S1 Sd<<(leftPart) &(spellsBits);
  *!IF&(SPELL_PROTECTION_FROM_FIRE)=(spellID):M^%(leftPart)  %(spellsBits)^;

  ; проверяем на запрет искомое заклинание в городе
  !!if&(isSpellBannedInTown)<>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;

  ; работаем с битами запрета заклинаний в игре
  !!UN:C6919480/4/?(gameMgr:y); 
  !!VR(spellBannedOfsset:y):S74 +(spellID);
  !!UN:C(gameMgr)/(spellBannedOfsset)/1/?(isSpellBannedInGame:y);

  ; проверяем на запрет искомое заклинание в игре
  !!if&(isSpellBannedInGame)>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;


  !?FU(Town_CanBuildingBuilt);
  ; x1 - town number on map (0...47)
  ; x2 - building id
  ; x3 - return: bool (0-no, 1-yes)
  !!FU(gem_Town_GetStruct):Px1/?y1;
  !!CA0/x1:R?y2 R0;
  !!SN:E6033696/2/y1/x2;
  !!VRx3:S0;    
  !!VRx3&v1<>0:S1;
  !!CA0/x1:Ry2;









