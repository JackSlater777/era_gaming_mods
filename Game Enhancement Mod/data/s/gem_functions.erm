ZVSE2
; gem_functions.erm
; version 1.00
; author: daemon_n.

********************************Add Own Button In Town Menu Dialog**********************************
Allows to add own inTown interaction via Custom Dialog i ve made
You need set .def of the button -- recomend size is 66x32 px
buttons are added one by one, depend on the called "gem_AddTownButton" function amount



!?FU(gem_OnOpenButtonDlg); 
Triggers when buttons been added. Occurs when Dialog being called;
Use this for adding your button;
You can only set!

;*!FU(gem_AddTownButton):P(z1)/(z2)/(z3)/(y1)/(y2)/(y3)/(y4); function of the btn adding
;(z1) = ^myOwnDef.def^ - Name of The .def file for the button;
;(z2) = ^textHintWhenMouseOver^ - contents Hint for the button in bottom part
;(z3) = ^RightCLickingText^ - PopUp message on the Right-CLicking on the your button
;(y1) = (FunctionNameToLaunch) - name of the function, use without symbols like (!FU) and (;)
;(y2) = optional integer 1st value for the your function launch, leave it empty, if not needed
;(y3) = optional integer 2nd value for the your function launch, leave it empty, if not needed
;(y4) = optional integer 3rd value for the your function launch, leave it empty, if not needed

!?FU(gem_OnOpenButtonDlg);&i^gem_TownScreenIsOpened^=1; 
  *!re i/0/13;
    *!VR(odd:y):R0/7/60;
    *!if&(odd);
      *!FU(gem_AddTownButton):P^smalres.def^/15/(odd)/^{~text align=left} what for %i  }^/^hint for me %i^/^text for me %i^/(gem_some_rand_fu)/i/2/1;

    *!el;
      *!FU(gem_AddTownButton):P^resource.def^/64/64/^{~text align=left} what for %i }^/^hint for me %i^/^rmb for me %i^/(gem_some_rand_fu)/i/1/2;
    *!en;
    *!FU(gem_AddTownButton):P^resource.def^/35/35/^hint for me1^/^text for me^/(gem_some_rand_fu)/0/0/1;
    *!FU(gem_AddTownButton):P^smalres.def^/35/15/^hint for me3^/^text for me^/(gem_some_rand_fu)/0/0/2;
    *!FU(gem_AddTownButton):P^resource.def^/35/35/^hint for me2^/^text for me^/(gem_some_rand_fu)/0/1/0;
    *!FU(gem_AddTownButton):P^smalres.def^/35/15/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/1/2;
  *!en;
  *!FU(gem_AddTownButton):P^artifact.def^/20/20/^123^/^321^/^456^/(MyNum)/(arg1:y)/(arg2:y)/(arg3:y);

  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/0;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/1;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/0/2/2;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/(gem_some_rand_fu)/1/0/0;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me4^/^text for me^/^gem_some_rand_fu^/4/5/6;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me1^/^text for me^/(gem_some_rand_fu)/4/5/6;
  *!FU(gem_AddTownButton):P^smalres.def^/^hint for me3^/^text for me^/(gem_some_rand_fu)/4/5/6;
  *!VRi^gem_TownScreenIsOpened^:S2;

!?FU(gem_some_rand_fu);
  *!IF:L^%x1 %x2 %x3^;

!?FU(gem_CheckModFolderNameExists);         [that function get mod list in array from !FU(gem_GetModList) and compare each folder with]
!#VA(modNameForCheck:x) (isExist:x);
  !!VR(emptyStr:z):S^%z(modNameForCheck)^ H1;
  !!if|1/(emptyStr)=^^;        [show error if mod name is not string or empty]
    !!IF:M^{The mod name you are trying to check is incorrect!}^;
    !!FU:E;
  !!en;

  !!VR(textModNameForCheck:z):S^%z(modNameForCheck)^;
  !!FU(gem_GetModList):P?(modListArrayID:y)/?(modsAmount:y);

  !!FU(StrToLower):P(textModNameForCheck)/?(textModNameForCheck);

  !!re i/0/(modsAmount)/1/-1;
    !!SN:M(modListArrayID)/i/?(modName:z);
    !!FU(StrToLower):P(modName)/?(modName);

    !!if&(textModNameForCheck)=(modName);
      !!VR(isExist):S(TRUE);
      !!FU:E;    
    !!en;
  !!en;

  !!VR(isExist):S(FALSE);


!?FU(gem_GetModList);
!#VA(modListArrayID:x) (modsAmount:x) (modListGlobalVar:x); 
  !!FU:A?(numArgs:y);

  *!if&(numArgs)<2;
    *!SN:F^ShowErmError^/^Substr: invalid arguments number. Expected at least {2} arguments^;
    *!FU:E;
  *!en;


  !!SN:L^vfs.dll^/?(dll:y) A(dll)/^GetMappingsReportA^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL);
  !!SN:Bv1/v1/?s^gem_modList^;
  !!VR(savedV1:y):Sv1;
  !!SN:A(dll)/^MemFree^/?(funcAddr:y) E(funcAddr)/(CALLCONV_STDCALL)/(savedV1);
  !!SN:Ks^gem_modList^/?(textLength:y);

  !!VR(garbageLength:y):S(NULL);
  !!VR(endOfGarbage:y):S(NULL);
  !!VR(skipNextText:y):S(FALSE);
  !!FU(NewIntArray):P?(modNamesEndings:y);
  !!VRs^gem_modListCut^:S^^;

  !!re i/0/(textLength)/1/-1;

    !!SN:Ks^gem_modList^/i/?(textSymbol:z);

    !!if&(textSymbol)=^$^;
      !!VRi:+10;
      !!VRk:Si+1;
      !!VR(modStart:y):Sk;
      !!co;
    !!en;

    !!if&(textSymbol)=^[^;
      !!if&(garbageLength);
        !!VRi:+(garbageLength);
        !!co;
      !!el;
        !!VR(startOfTextGarbage:y):Si;
        !!VR(skipNextText):S(TRUE);
      !!en;
    !!en;

    !!if&(textSymbol)=^]^;
        !!VR(garbageLength):Si -(startOfTextGarbage);
        !!VR(skipNextText):S(FALSE);
        !!co;
    !!en;

    !!VRs^gem_modListCut^&(skipNextText)=(FALSE):+^%(textSymbol)^;
  !!en;

  !!SN:Ks^gem_modListCut^/?(textLength:y);

  !!FU(NewStrArray):P?(modListArrayID);

  !!re i/0/(textLength)/1/-1;
    !!SN:Ks^gem_modListCut^/i/?(textSymbol);

    !!if&(textSymbol)=^\^;
      !!VR(modsAmount):+1;
      !!co;
    !!en;

    !!VRs^gem_mod_no_%(modsAmount)^:+(textSymbol);
  !!en;

  !!VRs^gem_modList^:S^^;
  !!VRs^gem_modListCut^:S^^;

  !!re i/1/(modsAmount);
    !!VRs^gem_mod_no_%i^:M6/?(latSymbol:y);
    !!VR(latSymbol):+1;
    !!VRs^gem_mod_no_%i^:M1/s^gem_mod_no_%i^/0/(latSymbol);
    !!FU(Array_Push):P(modListArrayID)/s^gem_mod_no_%i^;

    !!if&(numArgs)>2;                                   [if user asked mod list]
      !!VRs^gem_modListCut^:+^%s(gem_mod_no_%i)
^;                                             [add mod to the list on the next line]
    !!en;

    !!VRs^gem_mod_no_%i^:S^^;                           [remove global var]
  !!en;

  !!SN:F^ExtendArrayLifetime^/(modListArrayID);         [return id of array with mod list]

  !!if&(numArgs)>2;                                     [if user asked mod list]

    !!VRs^gem_modListCut^:M6/?(latSymbol);

    !!VR(latSymbol):+1;
    !!VRs^gem_modListCut^:M1/s^gem_modListCut^/0/(latSymbol);
    !!VR(modListGlobalVar):Z^{~text align=left}%s(gem_modListCut)}^;
  !!en;

!?FU(gem_ExtractIntsFromText);                        [returns only integer numbers as int array elements from string]
  !#VA(strPtr:x);                       [Original string.]
  !#VA(numbersArrayID:x);               [returns local array id via ?(intVar:y)]
  !#VA(amountOfNumbers:x);              [returns local array size ]

  !!VRs^gem_originalString^:S^%z(strPtr)^;
  !!SN:Ks^gem_originalString^/?(strLength:y);

  !!VR(amountOfNumberArrays:y):S1;
  !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
  !!VR(breakPoint:y):S(NULL);
  !!VR(isNeedBreakPoint:y):S(FALSE);
  !!re i/0/(strLength)/1/-1;
    !!SN:Ks^gem_originalString^/i/?(checkSymbol:z);

    !!VR(isNeedBreakPoint):S(TRUE);

    !!re (commonInt:y)/0/9;
      !!if&(checkSymbol)=^%(commonInt)^;
        !!FU(Array_Push):Pi^current_%(amountOfNumberArrays)_array_ID^/(commonInt);
        !!VR(isNeedBreakPoint):S(FALSE);
        !!br;
      !!en;
    !!en;

    !!if&(isNeedBreakPoint);
      !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
      !!co&(arrayLength)=(NULL);
      !!VR(amountOfNumberArrays):+1;
      !!FU(NewIntArray):P?i^current_%(amountOfNumberArrays)_array_ID^;
    !!en;

  !!en;


  !!VRs^gem_originalString^:S^^;
  !!SN:Mi^current_%(amountOfNumberArrays)_array_ID^/?(arrayLength:y);
  !!VR(amountOfNumberArrays)&(arrayLength)=(NULL):-1;

  !!if&(amountOfNumberArrays);  
    !!FU(NewIntArray):P?(numbersArrayID:x);

    !!re i/1/(amountOfNumberArrays);

      !!VR(elemSumm:y):S(NULL);
      !!SN:Mi^current_%i_array_ID^/?(arrayLength:y);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:Mi^current_%i_array_ID^/j/?(elemValue:y);
        !!VR(multipler:y):S(arrayLength) -j -1;

        !!if&(multipler);
          !!re k/1/(multipler);
            !!VR(elemValue):*10;
          !!en;
        !!en;

        !!VR(elemSumm):+(elemValue);
      !!en;

      !!FU(Array_Push)&(arrayLength):P(numbersArrayID)/(elemSumm);
      !!VRi^current_%i_array_ID^:S(NULL);
    !!en;

    !!FU:A?(numArgs:y);

    !!if&(numArgs)>3;
      !!VR(totalInt:x):S(NULL);
      !!VR(fullText:z):S^^;
      !!SN:M(numbersArrayID)/?(arrayLength);

      !!re j/0/(arrayLength)/1/-1;

        !!SN:M(numbersArrayID)/j/?(elemValue:y);
        !!SN:K^%(elemValue)^/?(intLength:y);

        !!re l/0/(intLength)/1/-1;
          !!SN:K^%(elemValue)^/l/?(textSymbol:z);
          !!VR(fullText):+(textSymbol);
        !!en;

      !!en;

    !!en;

    !!VR(amountOfNumbers):S(amountOfNumberArrays);
    !!SN:F^ExtendArrayLifetime^/(numbersArrayID);
  !!el;
    !!IF:M^There are no numbers in the text you entered^;
  !!en;




+16 | id
+22 | state;
+24 | xPos;
+26 | yPos;
+28 | width;
+30 | height;
+32 | text ptr in status_bar;
+36 | text ptr on text by RMB;
+48 | def structure ptr;
+52 | def frame number;
+56 | def frame number when pressed (if button);
+60 | mirror: 0-no, 1-yes;
+68 | Does the dialog close: 0-no, 1-yes; - only set
^;
*!en;

!?FU(gem_DlgDefProc);
!#VA(itemId:x) (currentFrame:x) (whenPressedFrame:x) (whenDisabledFrame:x) (closeDlg:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

  !!SN:E6288816/2/(currentDlgStruct)/(itemId);

  !!if&v1<1;
  *!IF:L^%^;
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:S(@currentFrame)/?(cFSyntax:y) S(@whenPressedFrame)/?(wPFSyntax:y) S(@whenDisabledFrame)/?(wDFSyntax:y) S(@closeDlg)/?(closeDlgSyntax:y);

  !!VR(itemAction:y):S(itemStructure) +52;
    !!UN&(cFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(currentFrame);
    !!UN&(cFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(currentFrame);
    
    !!if&(cFSyntax)=(ARG_SYNTAX_ADD);
      !!VR(addNumber:y):S(currentFrame);
      !!UN:C(itemAction)/4/?(currentFrame);
      !!VR(currentFrame):+(addNumber);
      !!UN:C(itemAction)/4/(currentFrame);
    !!en;


  !!VR(itemAction:y):S(itemStructure) +56;
    !!UN&(wPFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenPressedFrame);
    !!UN&(wPFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenPressedFrame);

  !!VR(itemAction:y):S(itemStructure) +60;
    !!UN&(wDFSyntax)=(ARG_SYNTAX_GET):C(itemAction)/4/?(whenDisabledFrame);
    !!UN&(wDFSyntax)=(ARG_SYNTAX_SET):C(itemAction)/4/(whenDisabledFrame);

  !!VR(itemAction:y):S(itemStructure) +68;
    !!UN&(closeDlgSyntax)=(ARG_SYNTAX_GET):C(itemAction)/2/?(closeDlg);
    !!UN&(closeDlgSyntax)=(ARG_SYNTAX_SET):C(itemAction)/2/(closeDlg);  

  !!VRv1:S(savedV1);

!?FU(gem_DlgDisableBtn);
!#VA(itemId:x) (enable:x) (whenDisabledFrame:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

   !!SN:E6288816/2/(currentDlgStruct)/(itemId);
   !!if&v1<1;
   
     !!FU:E;
   !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:A?(numArgs:y);
  !!if&(numArgs)>2;
    !!VR(itemAction:y):S(itemStructure) +60;
    !!UN:C(itemAction)/4/(whenDisabledFrame);
  !!en;

  !!SN:E6287104/2/(itemStructure)/(enable);
  !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);

!?FU(gem_DlgShowItem);
!#VA(itemId:x) (showItem:x) (clickableItem:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;


  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;

  !!SN:E6288816/2/(currentDlgStruct)/(itemId);

  !!if&v1<1;
  
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; 

  !!if&(showItem);

    !!SN:E6286720/2/(itemStructure)/5/6;
  !!el;

    *!FU:S(@clickableItem)/?(clickableItemSyntax:y);

    *!if&(clickableItemSyntax)=(ARG_SYNTAX_SET);
      !!if&(clickableItem);
        !!SN:E6286720/2/(itemStructure)/6/4;
      !!el;
        !!SN:E6286720/2/(itemStructure)/6/6;
      !!en;
    *!en;


  !!en;
*!IF:L^%(itemId)^;
  !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);

!?FU(gem_DlgItemSize);
!#VA(itemId:x) (width:x) (height:x) (redraw:x) (customDlgStruct:x);
  !!if&(itemId)<0;
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(currentDlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!en;
  !!SN:E6288816/2/(currentDlgStruct)/(itemId);
    !!if&v1<1;
    *!IF:M^itemId is incorrect!^;
    !!VR(width):S0;
    !!VR(height):S0;
    !!VRv1:S(savedV1);
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!FU:S(@width)/?(widthSyntax:y) S(@height)/?(heightSyntax:y) A?(argc:y);

  !!VR(itemAction:y):S(itemStructure) +28;

    !!if&(widthSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(width);
    !!el&(widthSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(width);
    !!el;
      !!UN:C(itemAction)/2/?(currWidth:y);
      !!VR(width):+(currWidth);

      !!if&(width)>0;
        !!UN:C(itemAction)/2/(width);
      !!el;
        !!UN:C(itemAction)/2/0;
      !!en;

    !!en;

  !!if&(argc)>(@width);
  
    !!VR(itemAction:y):S(itemStructure) +30;
    
    !!if&(heightSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(height);
    !!el&(heightSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(height);
    !!el;
      !!UN:C(itemAction)/2/?(currHeight:y);
      !!VR(height):+(currHeight);
      !!UN:C(itemAction)/2/(height);

      !!if&(height)>0;
        !!UN:C(itemAction)/2/(height);
      !!el;
        !!UN:C(itemAction)/2/0;
      !!en;
    !!en;


    !!SN&(redraw):E6288864/2/(currentDlgStruct)/1/-65535/65535; [update currentDlg;]

  !!en;


  !!VRv1:S(savedV1);


!?FU(gem_DlgItemPosition);
!#VA(itemId:x) (xPos:x) (yPos:x) (redraw:x) (customDlgStruct:x) (parrent:x);
  !!FU:A?(argNum:y);
  !!if|(itemId)<0/(argNum)<=(@itemId);
    !!IF:M^itemId is incorrect!
    should be 0 and higher^;
    !!FU:E;
  !!en;

  ; parameters of any dialog element
  ; text, pictures, buttons, etc.
  !!VR(savedV1:y):Sv1;

  !!if&(customDlgStruct);
    !!VR(dlgStruct:y):S(customDlgStruct);
  !!el;
    !!FU(H3Dlg_GetCurrentDlg):P?(dlgStruct:y);
  !!en;
  !!SN:E6288816/2/(dlgStruct)/(itemId);
  !!if&v1<1;
    !!VRv1:S(savedV1);
    *!IF:M^itemId is incorrect!^;
    !!FU:E;
  !!en;
  !!VR(itemStructure:y):Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

  !!VR(parrent):S(itemStructure) +4;
  !!UN:C(parrent)/4/?(parrent);
  !!FU:S(@xPos)/?(xSyntax:y);

  !!VR(itemAction:y):S(itemStructure) +24;
    !!if&(xSyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(xPos);
    !!el&(xSyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(xPos);
    !!el;
      !!UN:C(itemAction)/2/?(currX:y);
      !!VR(xPos):+(currX);
      !!UN:C(itemAction)/2/(xPos);
    !!en;

  !!FU&(argNum)<(@yPos):E;
  !!FU:S(@yPos)/?(ySyntax:y);

  !!VR(itemAction:y):S(itemStructure) +26;
    !!if&(ySyntax)=(ARG_SYNTAX_GET);
      !!UN:C(itemAction)/2/?(yPos);
    !!el&(ySyntax)=(ARG_SYNTAX_SET);
      !!UN:C(itemAction)/2/(yPos);
    !!el;
      !!UN:C(itemAction)/2/?(currY:y);
      !!VR(yPos):+(currY);
      !!UN:C(itemAction)/2/(yPos);    
    !!en;

  !!SN&(redraw):E6288864/2/(dlgStruct)/1/-65535/65535; [update currentDlg;]

  !!VRv1:S(savedV1);
!?FU(gem_GetItemByStructure);
!#VA(itemStructure:x) (itemId:x);

*!UN:C(itemAction)/2/?(y);

!?FU(gem_GetItemStructure);
!#VA(itemId:x) (itStructure:x);
  !!FU(H3Dlg_GetCurrentDlg):P?(currentDlgStruct:y);
  !!SN:E6288816/2/(currentDlgStruct)/(itemId);
  !!VR(itStructure)&v1>0:Sv1; [getItemStruture] item = (_Dlg_*)->GetItem(id)

!?FU(gem_DlgReload);
!#VA(dlgFileName:x);
  !!VRz1:S^%z(dlgFileName)^;
  !!SN:E5620400/3/z1;
  !!VRv2:Sv1+24;
  !!UN:Cv2/4/1;
  !!SN:E5624576/3/v1;
  *!IF:L^done!^;


!?FU(ChangeDwellingName);
!#VA(objSubtype:x) (name:x);
!!UN:C6886304/(UNC_INT)/?(txtPtr:y) C(txtPtr)/32/(UNC_INT)/?(txtPtr);
!!VR(objSubtype): *(UNC_INT)+(txtPtr);
!!UN:C(objSubtype)/(UNC_INT)/?(addr:y);

!!FU:S(@name)/?(nameSyntax:y);
!!if&(nameSyntax)=(ARG_SYNTAX_GET);
  !!SN:B(addr)/d/?(str:z);
  !!VR(name):Z(str);
!!el&(nameSyntax)=(ARG_SYNTAX_SET);
  !!SN:B(addr)/d/^%z(name)^;
!!el;
  !!SN:B(addr)/d/?(str:z);
  !!VR(str):+^%z(name)^;
  !!SN:B(addr)/d/(str);
!!en;

!?FU(gem_GetAdvDwellingName);
!#VA(objType:x) (objSubtype:x) (objName:x);
  !!FU:A?(numArgs:y) S(@objName)/(nameSyntax:y);

  !!if|(numArgs)<(@objName)/(nameSyntax)<>(ARG_SYNTAX_GET);
    !!IF:M^incorrect Arguments number or type!
    use only {GET} Syntax for getting dwelling name^;
    !!FU:E;
  !!en;

  !!if&(objType)<>(OBJ_CREATURE_GENERATOR_1)/(objType)<>(OBJ_CREATURE_GENERATOR_4);
    !!IF:M^incorrect object Type number!
    use only Types %(OBJ_CREATURE_GENERATOR_1) or %(OBJ_CREATURE_GENERATOR_4) object Types^;
    !!FU:E;
  !!en;

  !!UN&(objType)=(OBJ_CREATURE_GENERATOR_1):C6886304/4/?y1;            [crGen1.txt adress]
  !!UN&(objType)=(OBJ_CREATURE_GENERATOR_4):C6887052/4/?y1;            [crGen4.txt adress]

; @Master Of Puppets

  !!VRy1:+32;
  !!UN:Cy1/4/?y2;
  !!VR(objSubtype):*4+y2;
  !!UN:C(objSubtype)/4/?y1;
  !!SN:X?y4 Xy1 X?z1 Xy4;
  !!VR(objName):Z^%z1^;


006A6C5C [PriSkill.txt adress]
006A7584 PlColors.txt adress
006A75D8 
Garrison.txt
006A5438 MineName.txt
006A53F8 prim
006A5390 RESTYPES.TXT
004E6D87 SSTRAITS.TXT
; @Master Of Puppets

004E6BCB
006A60AC ARRAYTXT.TXT
!?FU(gem_GetTxtFileString);
!#VA(txtFileName:x) (stringNum:x) (string:x); 
  !!VR(txtLoadAddres:y):S0;Dwelling.txt

  !!FU(StrToLower):Pz(txtFileName)/?(txtName:z);(txtName:z);

  !!if|(txtName)=^objnames.txt^/(txtName)=^objnames^;
    !!VR(txtLoadAddres):+6974640;obj

  !!el|(txtName)=^arraytxt.txt^/(txtName)=^arraytxt^;
    !!VR(txtLoadAddres):+6971564;arraytxt

  !!el|(txtName)=^minename.txt^/(txtName)=^minename^;
    !!VR(txtLoadAddres):+6968376;mine

  !!el|(txtName)=^priskill.txt^/(txtName)=^priskill^;
    !!VR(txtLoadAddres):+6974556;ps

  !!el|(txtName)=^restypes.txt^/(txtName)=^restypes^;
    !!VR(txtLoadAddres):+6968208;rest

  !!el|(txtName)=^plcolors.txt^/(txtName)=^plcolors^;
    !!VR(txtLoadAddres):+6976900;plcol

  !!el|(txtName)=^dwelling.txt^/(txtName)=^dwelling^;
    !!VR(txtLoadAddres):+6972144;dwell

  !!el|(txtName)=^crgen1.txt^/(txtName)=^crgen1^;
    !!VR(txtLoadAddres):+6886304;[crGen1.txt adress]

  !!el|(txtName)=^crgen4.txt^/(txtName)=^crgen4^;
    !!VR(txtLoadAddres):+6887052;[crGen4.txt adress]

  *!el|(txtName)=^help.txt^/(txtName)=^help^;
    *!VR(txtLoadAddres):+6976896;[help.txt adress]

  !!el;
    !!VR(string):Z^Wrong txt file name!^;
    !!FU:E;
  !!en;

; @Master Of Puppets


  !!UN:C(txtLoadAddres)/4/?y1;            
  !!VRy1:+32;
  !!UN:Cy1/4/?y2;
  !!VR(stringNum):*4+y2;
  !!UN:C(stringNum)/4/?y1;
  !!SN:X?y4 Xy1 X?z1 Xy4;
  *!IF:L^%(stringNum) %y1^;
  *!VR(string):Z^%z1^;
!?FU(OnKeyPressed)&x1=(KEY_6);
*!VRy1:S6976896;

*!VRy1:S6887052;
44
*!UN:Cy1/4/?y2 Cy2/32/4/?y3;

*!UN:Cy3/1548/4/?y1 Cy1/36/4/?y1;
*!SN:By1/d/?z1;
*!IF:L^%z1 %y2^;



!?FU(gem_GetTxtTableString);
!#VA(txtLoadAddres:x) (rowNum:x) (colNum:x) (string:x);

!!VR(savedV1:y):Sv1;
!!SN:E7827723/(CALLCONV_CDECL)/(rowNum)/(colNum)/(txtLoadAddres);
!!SN:Bv1/d/?(text:z);
!!VR(string):Z(text);
!!VRv1:S(savedV1);

!!FU:E;

!!if|(rowNum)<1/(colNum)<1;
  !!IF:M^minimal row/col index is "1"^;
!!en;
!!UN:C(txtLoadAddres)/4/?(txtTablePtr:y) C(txtTablePtr:y)/32/4/?(vTablePtr:y);

!!VR(rowNum):*(UNC_INT);
!!VR(colNum):*(UNC_INT) +28;

!!UN:C(vTablePtr)/(rowNum)/(UNC_INT)/?(rowPtr:y) C(rowPtr)/(colNum)/(UNC_INT)/?(cellPtr:y);
!!SN:B(cellPtr)/d/?(text:z);
!!VR(string):Z(text);



!?FU(gem_DlgSetColor);
  !#VA(dlgStruct:x) (setColor:x);
  !!SN:E7510739/1/(dlgStruct);
  !!UN:Cv1/4/?y1;
  !!VRy2:Sy1 +76;
  !!UN:Cy2/4/?y3;
  !!SN:E6288384/2/y1/512/13/y3/(setColor);


!?FU(gem_Town_GetStruct);
; x1 - town number on map (0...47)
;?x2 - return: itemId structure town
!#VA(townId:x) (buildId:x); 
  !!IF&(townId)<(MAP_TOWN_FIRST)|(townId)>(MAP_TOWN_LAST):M^{FU(gem_Town_GetStruct)}: Wrong town id.^;
  !!UN:C(GAME_MANAGER)/(UNC_UINT32)/?(game:y); 
  !!UN:C(game)/136724/(UNC_UINT32)/?(itemId:y); 
  !!VR(buildId):S(townId) *360 +(itemId);
  !!IF&(buildId)<43200000:M^{FU(gem_Town_GetStruct): Attention!}
  Error in getting town structure address. 
  The game may fall at any time.^; 

!?FU(Town_IsSpellBanned); @igrik - so much thanks
!#VA(townId:x) (spellID:x) (result:x);
  !!VR(result):S(FALSE);

  ; получаем структуру города
  !!FU(gem_Town_GetStruct):P(townId)/?(town:y);

  ; работаем с битами запрета заклинаний в городе
  ; bit = (1 << (id & 31) & *(spellsBits + (id >> 5)) )
  !!VR(bitOffset:y):S(spellID) :32 *4 +212;  212=смещение до забаненых спеллов (town->0xD4: int[4])
  !!UN:C(town)/(bitOffset)/4/?(spellsBits:y);
  !!VR(leftPart:y):S(spellID) &31;

  !!VR(isSpellBannedInTown:y):S1 Sd<<(leftPart) &(spellsBits);
  *!IF&(SPELL_PROTECTION_FROM_FIRE)=(spellID):M^%(leftPart)  %(spellsBits)^;

  ; проверяем на запрет искомое заклинание в городе
  !!if&(isSpellBannedInTown)<>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;

  ; работаем с битами запрета заклинаний в игре
  !!UN:C6919480/4/?(gameMgr:y); 
  !!VR(spellBannedOfsset:y):S74 +(spellID);
  !!UN:C(gameMgr)/(spellBannedOfsset)/1/?(isSpellBannedInGame:y);

  ; проверяем на запрет искомое заклинание в игре
  !!if&(isSpellBannedInGame)>0:;
    !!VR(result):S(TRUE);
    !!FU:E;
  !!en;


  !?FU(Town_CanBuildingBuilt);
  ; x1 - town number on map (0...47)
  ; x2 - building id
  ; x3 - return: bool (0-no, 1-yes)
  !!FU(gem_Town_GetStruct):Px1/?y1;
  !!CA0/x1:R?y2 R0;
  !!SN:E6033696/2/y1/x2;
  !!VRx3:S0;    
  !!VRx3&v1<>0:S1;
  !!CA0/x1:Ry2;