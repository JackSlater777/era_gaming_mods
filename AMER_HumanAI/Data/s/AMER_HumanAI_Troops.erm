ZVSE2
**
**  Written by Matteo "Ameranth" T. 2022.
**
**  Improves AI strength by simulating how a human consolidates troops on thier powerful hero(s).
**
**  Specifically, AI heroes who are not visible to any human in the game send their troops to their
**  two highest level heroes, who must also not be visible. Troops sent are those that match
**  troops the receiving heroes already have (upgraded or not). At least 1 of troops Tier <=5
**  are kept, to ensure heroes don't end up with no army at all.
**  --------------------------

**  --------------------------------------------------
**  Consts:
!#DC(HUAI_SENDTROOPS_LOWTIER) = 2;  //The <= tier of troop that a donor hero will always keep one of after sending troops.
**  --------------------------------------------------

    
    
**  --------------------------
**  Send troops from weaker heroes to AI's best/second-best:
!?FU(huAI_dailyAIBestHeroes)&i^huAI_funnelTroops^=(TRUE);
    !#VA(owner:x);
    
    !!FU&i^timerDay^<5:E;                                                       //Don't do troop sending before day 5. This gives the AI some time to establish who their major hero(es) will be.
    
    !!FU&i^huAI_currentHero_Count^<2:E;                                         //Exit if player doesn't own at least 2 heroes.
    !!FU(huAI_SendTroops_Main):P;
    
    
!?FU(huAI_SendTroops_Main);
    !!FU(huAI_CanPlayerSee):Pi^huAI_currentHero_1^/i^huAI_currentHero_2^/?(bestVisible:y)/?(secondVisible:y);       //Get if any human player can see best/second-best heroes.
    !!FU&(bestVisible)=(TRUE)/(secondVisible)=(TRUE):E;                         //Exit if both best/second-best hero are visible, since we have nothing to do.
    
    !!re i/2/i^huAI_currentHero_Count^:;                                        // 2=index of second-best hero. We don't want to send units from best hero.
        !!VR(loopHero:y):Si^huAI_currentHero_%i^;
        
        !!FU(huAI_CanPlayerSee):P(loopHero)/-1/?(loopHeroVisible:y)/1;          //Get if any human player can see iterated hero.
        !!if&(loopHeroVisible)=(FALSE):;                                        //Only send troops if donor hero is not visible.
            !!VR(donorHasArmy:y):S(FALSE);                                      //Default false, this may be set to true during huAI_SendTroops.
            !!FU(huAI_SendTroops)&(bestVisible)=(FALSE):P(loopHero)/i^huAI_currentHero_1^/?(donorHasArmy);
            !!FU(huAI_SendTroops)&i^huAI_currentHero_2^>(NO_HERO)/(secondVisible)=(FALSE)/(loopHero)<>i^huAI_currentHero_2^/(donorHasArmy)=(TRUE):P(loopHero)/i^huAI_currentHero_2^/?(donorHasArmy);    //If also not second best and still have an army, try sending troops there as well.
            !!FU(huAI_PreventNoArmy)&(donorHasArmy)=(FALSE):P(loopHero);        //If hero has no army, provide them with 1 troop from their starting army.
        !!en:;
    !!en:;
**  --------------------------



**  --------------------------
**  Grant 1 troop of slot0 from hero's starting army.
!?FU(huAI_PreventNoArmy);
    !#VA(hero:x);
    !!HE(hero):H0/?(monType:y)//;           //Get type of troop to create.
    !!HE(hero):C2/(monType)/1/0;            //Give 1 of the troop.
**  --------------------------
    
    
    
**  --------------------------
**  Can any human player see passed hero(es). returns 1 if yes, else returns 0.
!?FU(huAI_CanPlayerSee);
    !#VA(firstHero:x);
    !#VA(secondHero:x);                 //Optional, use -1 to ignore.
    !#VA(firstHeroOutput:x);
    !#VA(secondHeroOutput:x);
    
    !!VR(firstHeroOutput):S(FALSE);     //Default not visible.
    !!VR(secondHeroOutput):S(FALSE);
    
    !!FU&i^huAI_funnelTroops_whileVisible^=(TRUE):E;            //Force return false if funnel always option is enabled, which results in always funneling.
    
    !!VR(visionBitToCheck:y):S1;                                //Bit to check for vision on tile. This is 1/2/4/8/16/32/64/128 for each player, respectively.
    !!re i/(PLAYER_FIRST)/(PLAYER_LAST):;
        !!OW:Ii/?(isAI:y)/?(isKilled:y);                        //Get if looped player is AI/killed.
        
        !!if&(isAI)=0/(isKilled)=0:;                            //Only continue if looped player is human and alive.
            !!if&(firstHeroOutput)=0:;
                !!HE(firstHero):P?(x:y)/?(y:y)/?(z:y)//0;       //get coords of hero.
                !!TR(x)/(y)/(z):V?(visionBits:y);               //Get bits of who sees this location.
                !!VR(visionBits):&(visionBitToCheck);           //Check if player sees it.
                !!if&(visionBits)>0:;
                    !!VR(firstHeroOutput):S(TRUE);              //If yes, set return value.
                !!en:;
            !!en:;
            !!if&(secondHeroOutput)=0/(secondHero)>-1:;
                !!HE(secondHero):P?(x:y)/?(y:y)/?(z:y)//0;      //get coords of hero.
                !!TR(x)/(y)/(z):V?(visionBits:y);               //Get bits of who sees this location.
                !!VR(visionBits):&(visionBitToCheck);           //Check if player sees it.
                !!if&(visionBits)>0:;
                    !!VR(secondHeroOutput):S(TRUE);             //If yes, set return value.
                !!en:;
            !!en:;
        !!en:;
        
        !!if&(firstHeroOutput)=1/(secondHeroOutput)=1:;
            !!FU:E;                                             //Exit since we know both heroes are visible, there is no need to keep checking.
        !!en:;
        
        !!VR(visionBitToCheck):*2;                              //set to bit for next player. This needs to happen even if the player was a human/not alive.
    !!en:;
**  --------------------------
    
    
    
**  --------------------------
**  Send troops from donorHero to receivingHero.
**  This is done by looping donorHero's army slots, and using a nested loop to see if it matches any of receivingHero's army slots.
**  Failing that, HE:C2 is used to offer the troops to AI even if it did not match any of receivingHero's army. If receivingHero
**  dismisses troops to accept those offered, we give the dismissed troops to donorHero, which emulates a "trade."
!?FU(huAI_SendTroops);
    !#VA(donorHero:x);
    !#VA(receivingHero:x);
    !#VA(armyRemains:x);        //Set to 1 if donorHero has any army remaining after sending troops. We use this to know if we need to give the donorHero a troop to prevent 0 army.
    
    !!VR(armyRemains):S(FALSE);
    
    !!re (donorSlot:y)/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST):;
        
        !!HE(donorHero):C0/(donorSlot)/?(monType:y)/?(monCount:y);      //Get troop in donorHero's army slot.
        !!co&(monType)=(NO_MON);                                        //co if this slot is empty.
        
        !!MA:L(monType)/?(monTier:y);                                   //get tier of troop
        !!if&(monTier)<=(HUAI_SENDTROOPS_LOWTIER):;
            !!VR(armyRemains):S(TRUE);                                  //We will always keep 1 of low tier troops, so we know army remains.
            !!co&(monCount)=1:;                                         //Don't send if only one troop remaining of low tier.
            !!HE(donorHero):C0/(donorSlot)/(monType)/d-1;               //If we are sending, reduce count by 1, so that one fewer is given to receivingHero via EX:C. Afterward we will add this troop back.
            !!EX(donorHero)/(donorSlot):E?(donorMonXP:y);               //Store donorMon's XP so we can give it back to the 1 mon we add back after donation is done.
        !!en:;
        
        !!FU(huAI_SendTroops_Internal):P(donorHero)/(receivingHero)/(monType)/(monCount)/(donorSlot)/?(donorSuccess:y);      //Send troops from donorHero's donorSlot to receivingHero.
        !!if&(donorSuccess)=(TRUE):;
            !!if&(monTier)<=(HUAI_SENDTROOPS_LOWTIER):;
                !!HE(donorHero):C0/(donorSlot)/(monType)/1;             //If donation is successful for low tier troop, reset donorHero count of troop to 1 (we must do this since we used EX:C to combine stacks).
                !!EX(donorHero)/(donorSlot):E(donorMonXP);              //Give the donor stack XP back to the 1 troop.
            !!en:;
            !!co:;                                                      //co if we successfully added this stack to an existing stack.
        !!en:;
        
        //If we did *not* send troops to a similar stack in receivingHero's army, try to offer the troops to the AI instead, using HE:C2:
        
        //!HE(donorHero):B0/?(donorHeroName:z);              TEST - Donor hero name
        //!HE(donorHero):O?(donorHeroOwner:y);               TEST
        //!HE(receivingHero):O?(receivingHeroOwner:y);       TEST
        //!SN:H^monname^/(monType)/0/?(monTypeStr:z);        TEST - Name of troop to send.
        //!IF:L^%(donorHeroName) asking if %(receivingHeroName) wants (%(monCount)) %(monTypeStr)...^;      TEST
        
        !!HE(receivingHero):C2/(monType)/(monCount)/0;                                      //Offer AI the troop stack. (monType) of count (monCount).
        !!FU(huAI_HasTroop):P(receivingHero)/(monType)/?(hasTroop:y)/?(receivingSlot:y);    //(donorSuccess)=1 if hero accepted the troops. (receivingSlot)=slot the troop was placed in.
        !!if&(hasTroop)=(FALSE):;
            !!VR(armyRemains):S(TRUE);                      //Troop was not accepted, so we know donorHero will still have army.
            !!co:;                                          //co if the troop was not found (not accepted)
        !!en:;
        
        //!SN:W^huAI_Troops_HeroMon_TEST_%(receivingSlot)^/?(oldMonTEST:y);     TEST
        !!SN:W^huAI_Troops_HeroMon_%(receivingSlot)^/?(oldMon:y);
        !!SN:W^huAI_Troops_HeroMonCount_%(receivingSlot)^/?(oldMonCount:y);     //Get old mon type and count, so we can give it to donorHero to facilitate a "trade."
        !!VR(monCountNegation:y):S(monCount)*-1;                                //Negation of troop count, to remove army from donor.
        !!if&(oldMon)>(NO_MON)/(oldMonCount)>0:;
            !!HE(donorHero):C0/(donorSlot)/(oldMon)/(oldMonCount);              //If receiving hero replaced an old troop to accept, set donor hero's sent troop slot to be the receiving hero's old troop.
            //!SN:H^monname^/(oldMon)/0/?(oldMonTypeStr:z);   TEST
            //!IF:L^%(donorHeroName)[%(donorHeroOwner)] TRADED: (%(monCount)) %(monTypeStr) for (%(oldMonCount)) %(oldMonTypeStr) to %(receivingHeroName)[%(receivingHeroOwner)].^;       TEST
        !!el:;
            !!HE(donorHero):C0/(donorSlot)/(monType)/d(monCountNegation);       //Else, just remove donor hero's sent troop count.
            //!IF:L^%(donorHeroName)[%(donorHeroOwner)] sent NEW stack (%(monCount)) %(monTypeStr) to %(receivingHeroName)[%(receivingHeroOwner)].^;    TEST
        !!en:;
        !!SN:W^huAI_Troops_HeroMon_%(receivingSlot)^/(monType);                 //Update receiving hero's army vars to the new creature type/count.
        !!SN:W^huAI_Troops_HeroMonCount_%(receivingSlot)^/(monCount);
    !!en:;
    
    
!?FU(huAI_SendTroops_Internal);
**    Send troops from donor if receiving hero has the troop, its upgrade, or its degrade.
**    Also store the troops that receiving hero has, so that we can potentially facilitate a trade of stacks back in the parent function.
    !#VA(donorHero:x);
    !#VA(receivingHero:x);
    !#VA(donorMonType:x);
    !#VA(donorMonCount:x);
    !#VA(donorMonArmySlot:x);
    !#VA(donorSuccess:x);           //Returns 1 if success.
        
    !!VR(donorSuccess):S(FALSE);      //Default return failure.
    
    !!re (receivingSlot:y)/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST):;
    
        !!HE(receivingHero):C0/(receivingSlot)/?(existingMon:y)/?(existingMonCount:y);        //Get Receving Hero's troop in this slot. (existingMon)=receiving hero's troop. (existingMonCount=receiving hero's troop's count.
        //!SN:W^huAI_Troops_HeroMon_TEST_%(receivingSlot)^/(existingMon);          TEST
        !!SN:W^huAI_Troops_HeroMon_%(receivingSlot)^/(existingMon);
        !!SN:W^huAI_Troops_HeroMonCount_%(receivingSlot)^/(existingMonCount);
        
        !!co|(existingMon)<0/(existingMonCount)<=0:;      //co if nothing in this slot.
        
        //Era framework function to find mon degrade mentions that is not 100% accurate,
        //and it is slow. Due to this, we use a simple but fast method to find degrade.
        //This is still not accurate, but it is efficient and good enough for this.
        //Minus 1 to troop index, then get its upgrade. If they match, degrade was found.
        !!VR(degradedMon:y):S-1;
        !!if&(donorMonType)>0:;                                                             //Don't attempt this if it's creature index 0, else we'll error since -1 is not valid.
            !!VR(degradedMon:y):S(donorMonType)-1;                                          //(degradedMon) might become *de*graded version of the troop passed.
            !!FU(GetUpgradedMonster):P(degradedMon)/?(degradedMonUpgrade:y);                //Get upgrade of degraded mon.
            !!VR(degradedMon)&(degradedMonUpgrade)<>(donorMonType):S-1;                     //If the upgrade of degraded mon is *not* the original mon, then this method of finding degrade failed.
        !!en:;
        
        !!FU(GetUpgradedMonster):P(donorMonType)/?(upgradedMon:y);       //Get troop upgrade, if it exists.
        
        !!if|(existingMon)=(donorMonType)/(existingMon)=(degradedMon)/(existingMon)=(upgradedMon):;        //Hero has passed troop, it's degrade, or its upgrade.
            //!SN:H^monname^/(donorMonType)/0/?(donorMonTypeStr:z);      TEST - Name of troop to send.
            //!HE(donorHero):B0/?(donorHeroName:z);              TEST - Donor hero name
            //!HE(receivingHero):B0/?(receivingHeroName:z);      TEST - Receiving hero name
            //!HE(donorHero):O?(donorHeroOwner:y);               TEST
            //!HE(receivingHero):O?(receivingHeroOwner:y);       TEST
            !!if&(existingMon)=(degradedMon):;
                !!EX(receivingHero)/(receivingSlot):E?(monXP:y);                                //Get XP of receiving troop stack, since upgrading the troop will delete xp (but it keeps stack arts).
                !!HE(receivingHero):C0/(receivingSlot)/(donorMonType)/d;                        //Donor has upgraded troops, and ours are degrade, so upgrade our troops before combining stacks.
                !!EX(receivingHero)/(receivingSlot):E(monXP);                                   //reset XP after upgrade.
                !!EX(receivingHero)/(receivingSlot):C0/(donorHero)/(donorMonArmySlot);          //combine donor's mon into receivingHero's mon.
                //!IF:L^%(donorHeroName)[%(donorHeroOwner)] sent UPG (%(donorMonCount)) %(donorMonTypeStr) to %(receivingHeroName)[%(receivingHeroOwner)].^;      TEST
            !!el:;
                !!if&(existingMon)<>(donorMonType):;
                    !!EX(donorHero)/(donorMonArmySlot):E?(monXP:y);                             //Get XP of receiving troop stack, since converting the troop will delete xp (but it keeps stack arts).
                    !!HE(donorHero):C0/(donorMonArmySlot)/(existingMon)/d;                      //We are using receiving hero's monID, so convert donorHero's monID to that one before combining stacks.
                    !!EX(donorHero)/(donorMonArmySlot):E(monXP);                                //reset XP after conversion.
                !!en:;
                !!EX(receivingHero)/(receivingSlot):C0/(donorHero)/(donorMonArmySlot);          //combine donor's mon into receivingHero's mon.
                //!SN:H^monname^/(existingMon)/0/?(existingMonStr:z);        TEST - Name of troop to send.
                //!IF:L^%(donorHeroName)[%(donorHeroOwner)] sent (%(donorMonCount)) %(existingMonStr) to %(receivingHeroName)[%(receivingHeroOwner)].^;      TEST
            !!en:;
            !!VR(donorSuccess):S(TRUE);             //Return success.
            !!FU:E;                                 //Exit since we're done with this troop.
        !!en:;
        
    !!en:;
**  --------------------------
    
    
**  --------------------------
!?FU(huAI_HasTroop);
**  Determine if hero has monType in any slot of their army.
    !#VA(hero:x);
    !#VA(monType:x);
    !#VA(monFound:x);               //Returns 1 if the troop was found.
    !#VA(monFoundSlot:x);           //Returns slot the troop was found in.
    
    !!VR(monFound):S(FALSE);
    
    !!re (heroArmySlot:y)/(ARMY_SLOT_FIRST)/(ARMY_SLOT_LAST):;
    
        !!HE(hero):C0/(heroArmySlot)/?(slotMon:y)/?(slotCount:y);        //Get Receving Hero's troop in this slot. y=4 receiving hero's troop.
        
        !!if&(slotMon)=(monType):;                      //If the looped troop is = the troop we're searching for.
            !!VR(monFound):S(TRUE);                     //Set return value.
            !!VR(monFoundSlot):S(heroArmySlot);
            !!FU:E;                                     //Exit since we're done.
        !!en:;
        
    !!en:;
**    --------------------------
    
    