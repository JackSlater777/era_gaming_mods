ZVSE2


!?FU(gem_CreateERMHook);
!!SN:Ex1/1/4854758/(Before_CB_MSG_Hook);[0x4A13E6 - for common CB]
!!SN:Ex1/1/4857430/(Before_CB_MSG_Hook);[0x4A1E56 - for Dragon Utopia]
!!SN:Ex1/1/4899257/(Before_CB_MSG_Hook);[0x4AC1B9 - for Crypt/Derelict Ship/Shipwreck]
!!SN:Ex1/1/4899229/(Crypt_SkipMsgIfVisited); [0x4AC19D - for plundered Crypt]
*!SN:Ex1/1/4248482/(GetCrBankText); [0040D3A2 - new delimeter for common CB] 


*?FU(GetCrBankText); // ПЕРЕПИСАТЬ, МЕНЯТЬ ED
*!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y); [get ebp]
*!UN:C(ebp)/20/1/?(isRmc:y); [get ebp+14h offset - address of bool (RMC/not RMC)]

*!if&(isRmc);
  *!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDI)/4/6685616; [get ebp+10h offset - address of delimeter and replace it with address of right delimeter]
*!en;


!?FU(Before_CB_MSG_Hook);
!!FU(WOG_AdvMgr_GetMapItem):Pv998/v999/v1000/?(mapItem:y); [mapItem:y - address]
!!OBv998/v999/v1000:T?(objType:y) U?(objSubtype:y);

!!VR(delim:z):S^=^;                     [define a delimeter to separate an object name from guard description in RMC hint string]

; hintString - a string from RMC hint
; Last number:
; 0 - Guarded by (10-19) creatures
; 1 - Guarded by мало (5-9) Зеленые драконы, и мало (5-9) Красные драконы, и пара (1-4) Золотые драконы, и пара (1-4) Черные драконы
!!SN&(objType)=16:E4248400/(CALLCONV_FASTCALL)/?(hintString:z)/(mapItem)/(objSubtype)/i^timerOwner^/(delim:z)/1; [Common CB: 0-6 - subtype]
*!SN&(objType)=85:E4248400/(CALLCONV_FASTCALL)/?(hintString:z)/(mapItem)/7/i^timerOwner^/^^/1;  [Shipwreck: 7 - subtype (16/7 from WOG table in memory)]
*!SN&(objType)=24:E4248400/(CALLCONV_FASTCALL)/?(hintString:z)/(mapItem)/8/i^timerOwner^/^^/1;  [Derelict Ship: 8 - subtype (16/8 from WOG table in memory)]
!!SN&(objType)=84:E4248400/(CALLCONV_FASTCALL)/?(hintString:z)/(mapItem)/9/i^timerOwner^/(delim:z)/1; [Crypt: 9 - subtype (16/9 from WOG table in memory)]
!!SN&(objType)=25:E4248400/(CALLCONV_FASTCALL)/?(hintString:z)/(mapItem)/10/i^timerOwner^/(delim:z)/1; [Dragon Utopia: 10 - subtype (16/10 from WOG table in memory)]

; Get a string with CB name (objName) from hint string
!!SN:K(hintString)/?(lenHintString:y);
!!VR(objName:z):S^^;

!!re i/0/(lenHintString)/1;
  !!SN:K(hintString)/i/?(char:z);
  !!if&(char)<>(delim:z);
    !!VR(objName):+(char);
  !!el;
    !!VRi:+1;
    !!br;
  !!en;
!!en;

; Get a string with guard description (guardDesc) from hint string
!!SN:K(objName)/?(lenName:y);
!!VR(guardDesc:z):S^^;
!!VR(lenName):+1;

!!re j/(lenName)/(lenHintString)/1;
  !!SN:K(hintString)/j/?(char:z);
  !!if&(char)<>(delim:z);
    !!VR(guardDesc):+(char);
  !!el;
    !!VRj:+1;
    !!br;
  !!en;
!!en;

; Calculate a string with guard description for a crypt
!!FU(CreatureBankCalcGuardsAndSetText)&(objType)=84:Pv998/v999/v1000/?(guardDesc:z);

; Add to the final message a string with guard description
!!VR(youHaveFoundMsgPtr:z)&(objType)=16:S^{%(objName)}%T(wog.endl)%T(wog.endl)%T(extra_hints.creature_banks.visiting1)^ +(objName) +^%T(extra_hints.creature_banks.visiting2)%T(wog.endl)%T(wog.endl)^ +(guardDesc); [Common CB]
!!VR(youHaveFoundMsgPtr:z)&(objType)=25:S^{%(objName)}%T(wog.endl)%T(wog.endl)%T(extra_hints.dragon_utopia.visiting)%T(wog.endl)%T(wog.endl)^ +(guardDesc); [Dragon Utopia]
!!VR(youHaveFoundMsgPtr:z)&(objType)=84:S^{%(objName)}%T(wog.endl)%T(wog.endl)%T(extra_hints.crypt.visiting)%T(wog.endl)%T(wog.endl)^ +(guardDesc); [Crypt]

; Put the final message into text buffer
!!SN:E6388190/(CALLCONV_CDECL)/6911016/(youHaveFoundMsgPtr:z);  [6911016 - txt buffer address]

; Make a hook
!!UN&(objType)=16:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/6911016; [Common CB]
!!UN&(objType)=25:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/6911016; [Dragon Utopia]
!!UN&(objType)=84:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/6911016; [Crypt]


!?OB84;
!!VR(playerBit:y):S1 Sd<<i^timerOwner^; [1 + offset for each next player]
!!CB998:Vd|(playerBit);                 [Add object to player as revealed]


!?FU(Crypt_SkipMsgIfVisited);
; Get crypt status. If plundered - skip the dialog with choice and jump to the "minus morale" dialog
!!CB998:T?(isVisited:y);
!!if&(isVisited);
  !!SN:X?y99/0;                         [it is: return NO_EXEC_DEFAULT]
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4899301; [0x4AC1E5; x1 - HookContext* c]
!!en;


!?FU(OnAdventureMapRightMouseClick);   
!!CM:P?(coordX:y)/?(coordY:y)/?(coordL:y);              [Get courser position]
!!SN:O?(coordX:y)/?(coordY:y)/?(coordL:y);              [Find building entrance in the clicking area]
!!OB(coordX)/(coordY)/(coordL):T?(objType:y) U?(objSubtype:y); [Get type and subtype]

!!VR(cryptType:y):S84;                                  [Crypt]

; A code for crypt - adding HotA-styled hint
!!if&(objType)=(cryptType);
  !!CB(coordX)/(coordY)/(coordL):V?(bitMask:y);           [Get bit mask of object visiting by all players]
  !!VR(playerBit:y):S1 Sd<<i^timerOwner^;                 [1 + offset for each next player]
  !!VR(bitMask):&(playerBit);                             [Once visited, reveal the crypt guards to the player]
!!en;


!?FU(CreatureBankCalcGuardsAndSetText);
!#VA(coordX:x) (coordY:x) (coordL:x) (guardDesc:x);

; Clear global strings for guard description
!!VRs^fullGuardDescription^:S^%T(extra_hints.guard_desc.guarded_by)^;
!!VRs^fullGuardDesc^:S^^; // for a string without last comma

; Loop for each stack in CB
!!FU(NewIntArray):P?(types:y) P?(nums:y); [create 2 empty arrays]

!!re i/0/(ARMY_SLOT_LAST);
  !!CB(coordX)/(coordY)/(coordL):Gi/?(guardType:y)/?(guardCount:y);
  !!co&(guardType)=(NO_MON); [if empty guard(-1)] - continue
  !!FU(Array_IndexOf):P(types)/(guardType)/?(index:y);
  !!if&(index)<>(NO_MON);
    !!SN:M(nums)/(index)/d(guardCount);
  !!el;
    !!FU(Array_Push):P(types:y)/(guardType) P(nums:y)/(guardCount);
  !!en;
!!en;

!!SN:M(types)/?(typesSize:y); [get size of types-array]
!!re i/0/(typesSize)/1/-1;
  !!SN:M(types)/i/?t M(nums)/i/?n;
  ;!IF:L^type = %t, num = %n^;
  !!SN:H^monname^/t/1/?(guardName:z); [1 - Plural name]
  !!FU(WOG_GetCreatureAmountString):Pn/?(guardCountDesc:z);
  !!VRs^fullGuardDescription^: +(guardCountDesc) +^ ^ +(guardName) +^%T(extra_hints.guard_desc.and)^;
!!en;

; Delete the last comma
!!SN:Ks^fullGuardDescription^/?(lenStr:y);
!!VR(lenStr):-2;
; Copy string without last symbol
!!re j/0/(lenStr)/1;
  !!SN:Ks^fullGuardDescription^/j/?(char:z);
  !!VRs^fullGuardDesc^:+(char);
!!en;

; Return the full string into main function
!!VR(guardDesc):Zs^fullGuardDesc^;  [guardDesc - addr of s^fullGuardDesc^]


!?FU(WOG_GetCreatureAmountString);
!#VA(totalGuardCnt:x) (returnedStr:x);

!!FU(WOG_GetStringByFilename):P^arraytxt^/176/?(strFew:z);  // 1-4
!!FU(WOG_GetStringByFilename):P^arraytxt^/179/?(strSeveral:z);  // 5-9
!!FU(WOG_GetStringByFilename):P^arraytxt^/182/?(strPack:z);  // 10-19
!!FU(WOG_GetStringByFilename):P^arraytxt^/185/?(strLots:z);  // 20-49
!!FU(WOG_GetStringByFilename):P^arraytxt^/188/?(strHorde:z);  // 50-99
!!FU(WOG_GetStringByFilename):P^arraytxt^/191/?(strThrong:z);  // 100-249
!!FU(WOG_GetStringByFilename):P^arraytxt^/194/?(strSwarm:z);  // 250-499
!!FU(WOG_GetStringByFilename):P^arraytxt^/197/?(strZounds:z);  // 500-999
!!FU(WOG_GetStringByFilename):P^arraytxt^/200/?(strLegion:z);  // 1000+

!!VR(returnedStr)&(totalGuardCnt)=0:Z^^; // Not nessesary
!!VR(returnedStr)&(totalGuardCnt)>=1/(totalGuardCnt)<=4:Z^%(strFew)^;
!!VR(returnedStr)&(totalGuardCnt)>=5/(totalGuardCnt)<=9:Z^%(strSeveral)^;
!!VR(returnedStr)&(totalGuardCnt)>=10/(totalGuardCnt)<=19:Z^%(strPack)^;
!!VR(returnedStr)&(totalGuardCnt)>=20/(totalGuardCnt)<=49:Z^%(strLots)^;
!!VR(returnedStr)&(totalGuardCnt)>=50/(totalGuardCnt)<=99:Z^%(strHorde)^;
!!VR(returnedStr)&(totalGuardCnt)>=100/(totalGuardCnt)<=249:Z^%(strThrong)^;
!!VR(returnedStr)&(totalGuardCnt)>=250/(totalGuardCnt)<=499:Z^%(strSwarm)^;
!!VR(returnedStr)&(totalGuardCnt)>=500/(totalGuardCnt)<=999:Z^%(strZounds)^;
!!VR(returnedStr)&(totalGuardCnt)>=1000:Z^%(strLegion)^;

**end
